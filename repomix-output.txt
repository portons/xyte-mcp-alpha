This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.claude/
  settings.local.json
.github/
  workflows/
    ci.yml
  dependabot.yml
docs/
  capabilities.json
  spec.md
  wrappers.md
examples/
  basic_usage.py
helm/
  templates/
    deployment.yaml
    service.yaml
  Chart.yaml
  values.yaml
k8s/
  deployment.yaml
  service.yaml
scripts/
  generate_capabilities.py
  generate_wrappers_md.py
  profile_server.py
  security_scan.sh
src/
  xyte_mcp_alpha/
    __init__.py
    __main__.py
    client.py
    config.py
    deps.py
    events.py
    http.py
    logging_utils.py
    models.py
    prompts.py
    resources.py
    server.py
    tasks.py
    tools.py
    user.py
    utils.py
tests/
  test_config.py
  test_discovery_and_events.py
  test_errors.py
  test_health.py
  test_metrics.py
  test_rate_limit.py
  test_validation.py
.env.example
.gitignore
AGENTS.md
CHANGELOG.md
Dockerfile
pyproject.toml
README.md
registry.yaml
requirements.txt
uv.lock

================================================================
Files
================================================================

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(git checkout:*)",
      "Bash(PATH=/usr/bin:/bin git checkout codex/implement-tasks-a1-and-a3-from-spec-md-qlzccx)",
      "Bash(/usr/bin/git checkout codex/implement-tasks-a1-and-a3-from-spec-md-qlzccx)",
      "Bash(/usr/bin/git merge main)",
      "Bash(/usr/bin/git status)",
      "Bash(/usr/bin/git fetch origin)",
      "Bash(/usr/bin/git branch -vv)",
      "Bash(/usr/bin/git add -A)",
      "Bash(/usr/bin/git push origin codex/implement-tasks-b3-and-b4-from-dos-spec-md-vd5nub)",
      "Bash(ruff check:*)",
      "Bash(python:*)",
      "Bash(source:*)",
      "Bash(uv run ruff:*)",
      "Bash(pip install:*)",
      "Bash(git fetch:*)",
      "Bash(git merge:*)",
      "Bash(/bin/bash -c \"git merge origin/main\")",
      "Bash(/bin/bash -c \"git status --short\")",
      "Bash(/bin/bash -c 'git commit -m \"Merge main branch and resolve conflicts\n\n- Merge instrumentation from main into server.py\n- Keep Context parameters in tools.py\n- Consolidate imports and implementations in utils.py\n- Accept main branch versions of test files\n- Preserve events module while integrating prompts\n\nðŸ¤– Generated with Claude Code\n\nCo-Authored-By: Claude <noreply@anthropic.com>\"')",
      "Bash(/bin/bash -c \"git push origin codex/implement-tasks-c1-and-c2-from-spec-md-0qv2on\")",
      "Bash(/bin/bash -c \"git status\")",
      "Bash(git add:*)",
      "Bash(/usr/bin/git push)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "Bash(/usr/bin/git -C /Users/porton/Projects/xyte-mcp-alpha add src/xyte_mcp_alpha/tools.py)",
      "Bash(/usr/bin/git -C /Users/porton/Projects/xyte-mcp-alpha commit -m \"Fix linting errors: remove unused import and add missing logger\")",
      "Bash(/usr/bin/git -C /Users/porton/Projects/xyte-mcp-alpha push)",
      "Bash(lsof:*)"
    ],
    "deny": []
  }
}

================
File: uv.lock
================
version = 1
revision = 1
requires-python = ">=3.10"

[[package]]
name = "annotated-types"
version = "0.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ee/67/531ea369ba64dcff5ec9c3402f9f51bf748cec26dde048a2f973a4eea7f5/annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89", size = 16081 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/b6/6307fbef88d9b5ee7421e68d78a9f162e0da4900bc5f5793f6d3d0e34fb8/annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53", size = 13643 },
]

[[package]]
name = "anyio"
version = "4.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
    { name = "idna" },
    { name = "sniffio" },
    { name = "typing-extensions", marker = "python_full_version < '3.13'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/95/7d/4c1bd541d4dffa1b52bd83fb8527089e097a106fc90b467a7313b105f840/anyio-4.9.0.tar.gz", hash = "sha256:673c0c244e15788651a4ff38710fea9675823028a6f08a5eda409e0c9840a028", size = 190949 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a1/ee/48ca1a7c89ffec8b6a0c5d02b89c305671d5ffd8d3c94acf8b8c408575bb/anyio-4.9.0-py3-none-any.whl", hash = "sha256:9f76d541cad6e36af7beb62e978876f3b41e3e04f2c1fbf0884604c0a9c4d93c", size = 100916 },
]

[[package]]
name = "cachetools"
version = "5.5.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/6c/81/3747dad6b14fa2cf53fcf10548cf5aea6913e96fab41a3c198676f8948a5/cachetools-5.5.2.tar.gz", hash = "sha256:1a661caa9175d26759571b2e19580f9d6393969e5dfca11fdb1f947a23e640d4", size = 28380 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/72/76/20fa66124dbe6be5cafeb312ece67de6b61dd91a0247d1ea13db4ebb33c2/cachetools-5.5.2-py3-none-any.whl", hash = "sha256:d26a22bcc62eb95c3beabd9f1ee5e820d3d2704fe2967cbe350e20c8ffcd3f0a", size = 10080 },
]

[[package]]
name = "certifi"
version = "2025.4.26"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/e8/9e/c05b3920a3b7d20d3d3310465f50348e5b3694f4f88c6daf736eef3024c4/certifi-2025.4.26.tar.gz", hash = "sha256:0a816057ea3cdefcef70270d2c515e4506bbc954f417fa5ade2021213bb8f0c6", size = 160705 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/4a/7e/3db2bd1b1f9e95f7cddca6d6e75e2f2bd9f51b1246e546d88addca0106bd/certifi-2025.4.26-py3-none-any.whl", hash = "sha256:30350364dfe371162649852c63336a15c70c6510c2ad5015b21c2345311805f3", size = 159618 },
]

[[package]]
name = "click"
version = "8.1.8"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b9/2e/0090cbf739cee7d23781ad4b89a9894a41538e4fcf4c31dcdd705b78eb8b/click-8.1.8.tar.gz", hash = "sha256:ed53c9d8990d83c2a27deae68e4ee337473f6330c040a31d4225c9574d16096a", size = 226593 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7e/d4/7ebdbd03970677812aac39c869717059dbb71a4cfc033ca6e5221787892c/click-8.1.8-py3-none-any.whl", hash = "sha256:63c132bbbed01578a06712a2d1f497bb62d9c1c0d329b7903a866228027263b2", size = 98188 },
]

[[package]]
name = "colorama"
version = "0.4.6"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335 },
]

[[package]]
name = "deprecated"
version = "1.2.18"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "wrapt" },
]
sdist = { url = "https://files.pythonhosted.org/packages/98/97/06afe62762c9a8a86af0cfb7bfdab22a43ad17138b07af5b1a58442690a2/deprecated-1.2.18.tar.gz", hash = "sha256:422b6f6d859da6f2ef57857761bfb392480502a64c3028ca9bbe86085d72115d", size = 2928744 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6e/c6/ac0b6c1e2d138f1002bcf799d330bd6d85084fece321e662a14223794041/Deprecated-1.2.18-py2.py3-none-any.whl", hash = "sha256:bd5011788200372a32418f888e326a09ff80d0214bd961147cfed01b5c018eec", size = 9998 },
]

[[package]]
name = "exceptiongroup"
version = "1.3.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions", marker = "python_full_version < '3.13'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/0b/9f/a65090624ecf468cdca03533906e7c69ed7588582240cfe7cc9e770b50eb/exceptiongroup-1.3.0.tar.gz", hash = "sha256:b241f5885f560bc56a59ee63ca4c6a8bfa46ae4ad651af316d4e81817bb9fd88", size = 29749 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/36/f4/c6e662dade71f56cd2f3735141b265c3c79293c109549c1e6933b0651ffc/exceptiongroup-1.3.0-py3-none-any.whl", hash = "sha256:4d111e6e0c13d0644cad6ddaa7ed0261a0b36971f6d23e7ec9b4b9097da78a10", size = 16674 },
]

[[package]]
name = "h11"
version = "0.16.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/01/ee/02a2c011bdab74c6fb3c75474d40b3052059d95df7e73351460c8588d963/h11-0.16.0.tar.gz", hash = "sha256:4e35b956cf45792e4caa5885e69fba00bdbc6ffafbfa020300e549b208ee5ff1", size = 101250 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/04/4b/29cac41a4d98d144bf5f6d33995617b185d14b22401f75ca86f384e87ff1/h11-0.16.0-py3-none-any.whl", hash = "sha256:63cf8bbe7522de3bf65932fda1d9c2772064ffb3dae62d55932da54b31cb6c86", size = 37515 },
]

[[package]]
name = "httpcore"
version = "1.0.9"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "h11" },
]
sdist = { url = "https://files.pythonhosted.org/packages/06/94/82699a10bca87a5556c9c59b5963f2d039dbd239f25bc2a63907a05a14cb/httpcore-1.0.9.tar.gz", hash = "sha256:6e34463af53fd2ab5d807f399a9b45ea31c3dfa2276f15a2c3f00afff6e176e8", size = 85484 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7e/f5/f66802a942d491edb555dd61e3a9961140fd64c90bce1eafd741609d334d/httpcore-1.0.9-py3-none-any.whl", hash = "sha256:2d400746a40668fc9dec9810239072b40b4484b640a8c38fd654a024c7a1bf55", size = 78784 },
]

[[package]]
name = "httpx"
version = "0.28.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "certifi" },
    { name = "httpcore" },
    { name = "idna" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b1/df/48c586a5fe32a0f01324ee087459e112ebb7224f646c0b5023f5e79e9956/httpx-0.28.1.tar.gz", hash = "sha256:75e98c5f16b0f35b567856f597f06ff2270a374470a5c2392242528e3e3e42fc", size = 141406 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2a/39/e50c7c3a983047577ee07d2a9e53faf5a69493943ec3f6a384bdc792deb2/httpx-0.28.1-py3-none-any.whl", hash = "sha256:d909fcccc110f8c7faf814ca82a9a4d816bc5a6dbfea25d6591d6985b8ba59ad", size = 73517 },
]

[[package]]
name = "httpx-sse"
version = "0.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/4c/60/8f4281fa9bbf3c8034fd54c0e7412e66edbab6bc74c4996bd616f8d0406e/httpx-sse-0.4.0.tar.gz", hash = "sha256:1e81a3a3070ce322add1d3529ed42eb5f70817f45ed6ec915ab753f961139721", size = 12624 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e1/9b/a181f281f65d776426002f330c31849b86b31fc9d848db62e16f03ff739f/httpx_sse-0.4.0-py3-none-any.whl", hash = "sha256:f329af6eae57eaa2bdfd962b42524764af68075ea87370a2de920af5341e318f", size = 7819 },
]

[[package]]
name = "idna"
version = "3.10"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f1/70/7703c29685631f5a7590aa73f1f1d3fa9a380e654b86af429e0934a32f7d/idna-3.10.tar.gz", hash = "sha256:12f65c9b470abda6dc35cf8e63cc574b1c52b11df2c86030af0ac09b01b13ea9", size = 190490 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/76/c6/c88e154df9c4e1a2a66ccf0005a88dfb2650c1dffb6f5ce603dfbd452ce3/idna-3.10-py3-none-any.whl", hash = "sha256:946d195a0d259cbba61165e88e65941f16e9b36ea6ddb97f00452bae8b1287d3", size = 70442 },
]

[[package]]
name = "importlib-metadata"
version = "8.6.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "zipp" },
]
sdist = { url = "https://files.pythonhosted.org/packages/33/08/c1395a292bb23fd03bdf572a1357c5a733d3eecbab877641ceacab23db6e/importlib_metadata-8.6.1.tar.gz", hash = "sha256:310b41d755445d74569f993ccfc22838295d9fe005425094fad953d7f15c8580", size = 55767 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/79/9d/0fb148dc4d6fa4a7dd1d8378168d9b4cd8d4560a6fbf6f0121c5fc34eb68/importlib_metadata-8.6.1-py3-none-any.whl", hash = "sha256:02a89390c1e15fdfdc0d7c6b25cb3e62650d0494005c97d6f148bf5b9787525e", size = 26971 },
]

[[package]]
name = "markdown-it-py"
version = "3.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mdurl" },
]
sdist = { url = "https://files.pythonhosted.org/packages/38/71/3b932df36c1a044d397a1f92d1cf91ee0a503d91e470cbd670aa66b07ed0/markdown-it-py-3.0.0.tar.gz", hash = "sha256:e3f60a94fa066dc52ec76661e37c851cb232d92f9886b15cb560aaada2df8feb", size = 74596 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/42/d7/1ec15b46af6af88f19b8e5ffea08fa375d433c998b8a7639e76935c14f1f/markdown_it_py-3.0.0-py3-none-any.whl", hash = "sha256:355216845c60bd96232cd8d8c40e8f9765cc86f46880e43a8fd22dc1a1a8cab1", size = 87528 },
]

[[package]]
name = "mcp"
version = "1.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "httpx" },
    { name = "httpx-sse" },
    { name = "pydantic" },
    { name = "pydantic-settings" },
    { name = "python-multipart" },
    { name = "sse-starlette" },
    { name = "starlette" },
    { name = "uvicorn", marker = "sys_platform != 'emscripten'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/bc/8d/0f4468582e9e97b0a24604b585c651dfd2144300ecffd1c06a680f5c8861/mcp-1.9.0.tar.gz", hash = "sha256:905d8d208baf7e3e71d70c82803b89112e321581bcd2530f9de0fe4103d28749", size = 281432 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a5/d5/22e36c95c83c80eb47c83f231095419cf57cf5cca5416f1c960032074c78/mcp-1.9.0-py3-none-any.whl", hash = "sha256:9dfb89c8c56f742da10a5910a1f64b0d2ac2c3ed2bd572ddb1cfab7f35957178", size = 125082 },
]

[package.optional-dependencies]
cli = [
    { name = "python-dotenv" },
    { name = "typer" },
]

[[package]]
name = "mdurl"
version = "0.1.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d6/54/cfe61301667036ec958cb99bd3efefba235e65cdeb9c84d24a8293ba1d90/mdurl-0.1.2.tar.gz", hash = "sha256:bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba", size = 8729 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b3/38/89ba8ad64ae25be8de66a6d463314cf1eb366222074cfda9ee839c56a4b4/mdurl-0.1.2-py3-none-any.whl", hash = "sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8", size = 9979 },
]

[[package]]
name = "opentelemetry-api"
version = "1.33.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "deprecated" },
    { name = "importlib-metadata" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9a/8d/1f5a45fbcb9a7d87809d460f09dc3399e3fbd31d7f3e14888345e9d29951/opentelemetry_api-1.33.1.tar.gz", hash = "sha256:1c6055fc0a2d3f23a50c7e17e16ef75ad489345fd3df1f8b8af7c0bbf8a109e8", size = 65002 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/05/44/4c45a34def3506122ae61ad684139f0bbc4e00c39555d4f7e20e0e001c8a/opentelemetry_api-1.33.1-py3-none-any.whl", hash = "sha256:4db83ebcf7ea93e64637ec6ee6fabee45c5cbe4abd9cf3da95c43828ddb50b83", size = 65771 },
]

[[package]]
name = "opentelemetry-sdk"
version = "1.33.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "opentelemetry-api" },
    { name = "opentelemetry-semantic-conventions" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/67/12/909b98a7d9b110cce4b28d49b2e311797cffdce180371f35eba13a72dd00/opentelemetry_sdk-1.33.1.tar.gz", hash = "sha256:85b9fcf7c3d23506fbc9692fd210b8b025a1920535feec50bd54ce203d57a531", size = 161885 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/df/8e/ae2d0742041e0bd7fe0d2dcc5e7cce51dcf7d3961a26072d5b43cc8fa2a7/opentelemetry_sdk-1.33.1-py3-none-any.whl", hash = "sha256:19ea73d9a01be29cacaa5d6c8ce0adc0b7f7b4d58cc52f923e4413609f670112", size = 118950 },
]

[[package]]
name = "opentelemetry-semantic-conventions"
version = "0.54b1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "deprecated" },
    { name = "opentelemetry-api" },
]
sdist = { url = "https://files.pythonhosted.org/packages/5b/2c/d7990fc1ffc82889d466e7cd680788ace44a26789809924813b164344393/opentelemetry_semantic_conventions-0.54b1.tar.gz", hash = "sha256:d1cecedae15d19bdaafca1e56b29a66aa286f50b5d08f036a145c7f3e9ef9cee", size = 118642 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0a/80/08b1698c52ff76d96ba440bf15edc2f4bc0a279868778928e947c1004bdd/opentelemetry_semantic_conventions-0.54b1-py3-none-any.whl", hash = "sha256:29dab644a7e435b58d3a3918b58c333c92686236b30f7891d5e51f02933ca60d", size = 194938 },
]

[[package]]
name = "prometheus-client"
version = "0.22.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/5b/5a/3fa1fa7e91a203759aaf316be394f70f2ef598d589b9785a8611b6094c00/prometheus_client-0.22.0.tar.gz", hash = "sha256:18da1d2241ac2d10c8d2110f13eedcd5c7c0c8af18c926e8731f04fc10cd575c", size = 74443 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/50/c7/cee159ba3d7192e84a4c166ec1752f44a5fa859ac0eeda2d73a1da65ab47/prometheus_client-0.22.0-py3-none-any.whl", hash = "sha256:c8951bbe64e62b96cd8e8f5d917279d1b9b91ab766793f33d4dce6c228558713", size = 62658 },
]

[[package]]
name = "pydantic"
version = "2.11.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "annotated-types" },
    { name = "pydantic-core" },
    { name = "typing-extensions" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/77/ab/5250d56ad03884ab5efd07f734203943c8a8ab40d551e208af81d0257bf2/pydantic-2.11.4.tar.gz", hash = "sha256:32738d19d63a226a52eed76645a98ee07c1f410ee41d93b4afbfa85ed8111c2d", size = 786540 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e7/12/46b65f3534d099349e38ef6ec98b1a5a81f42536d17e0ba382c28c67ba67/pydantic-2.11.4-py3-none-any.whl", hash = "sha256:d9615eaa9ac5a063471da949c8fc16376a84afb5024688b3ff885693506764eb", size = 443900 },
]

[[package]]
name = "pydantic-core"
version = "2.33.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ad/88/5f2260bdfae97aabf98f1778d43f69574390ad787afb646292a638c923d4/pydantic_core-2.33.2.tar.gz", hash = "sha256:7cb8bc3605c29176e1b105350d2e6474142d7c1bd1d9327c4a9bdb46bf827acc", size = 435195 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e5/92/b31726561b5dae176c2d2c2dc43a9c5bfba5d32f96f8b4c0a600dd492447/pydantic_core-2.33.2-cp310-cp310-macosx_10_12_x86_64.whl", hash = "sha256:2b3d326aaef0c0399d9afffeb6367d5e26ddc24d351dbc9c636840ac355dc5d8", size = 2028817 },
    { url = "https://files.pythonhosted.org/packages/a3/44/3f0b95fafdaca04a483c4e685fe437c6891001bf3ce8b2fded82b9ea3aa1/pydantic_core-2.33.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:0e5b2671f05ba48b94cb90ce55d8bdcaaedb8ba00cc5359f6810fc918713983d", size = 1861357 },
    { url = "https://files.pythonhosted.org/packages/30/97/e8f13b55766234caae05372826e8e4b3b96e7b248be3157f53237682e43c/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0069c9acc3f3981b9ff4cdfaf088e98d83440a4c7ea1bc07460af3d4dc22e72d", size = 1898011 },
    { url = "https://files.pythonhosted.org/packages/9b/a3/99c48cf7bafc991cc3ee66fd544c0aae8dc907b752f1dad2d79b1b5a471f/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:d53b22f2032c42eaaf025f7c40c2e3b94568ae077a606f006d206a463bc69572", size = 1982730 },
    { url = "https://files.pythonhosted.org/packages/de/8e/a5b882ec4307010a840fb8b58bd9bf65d1840c92eae7534c7441709bf54b/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:0405262705a123b7ce9f0b92f123334d67b70fd1f20a9372b907ce1080c7ba02", size = 2136178 },
    { url = "https://files.pythonhosted.org/packages/e4/bb/71e35fc3ed05af6834e890edb75968e2802fe98778971ab5cba20a162315/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:4b25d91e288e2c4e0662b8038a28c6a07eaac3e196cfc4ff69de4ea3db992a1b", size = 2736462 },
    { url = "https://files.pythonhosted.org/packages/31/0d/c8f7593e6bc7066289bbc366f2235701dcbebcd1ff0ef8e64f6f239fb47d/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6bdfe4b3789761f3bcb4b1ddf33355a71079858958e3a552f16d5af19768fef2", size = 2005652 },
    { url = "https://files.pythonhosted.org/packages/d2/7a/996d8bd75f3eda405e3dd219ff5ff0a283cd8e34add39d8ef9157e722867/pydantic_core-2.33.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:efec8db3266b76ef9607c2c4c419bdb06bf335ae433b80816089ea7585816f6a", size = 2113306 },
    { url = "https://files.pythonhosted.org/packages/ff/84/daf2a6fb2db40ffda6578a7e8c5a6e9c8affb251a05c233ae37098118788/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:031c57d67ca86902726e0fae2214ce6770bbe2f710dc33063187a68744a5ecac", size = 2073720 },
    { url = "https://files.pythonhosted.org/packages/77/fb/2258da019f4825128445ae79456a5499c032b55849dbd5bed78c95ccf163/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_armv7l.whl", hash = "sha256:f8de619080e944347f5f20de29a975c2d815d9ddd8be9b9b7268e2e3ef68605a", size = 2244915 },
    { url = "https://files.pythonhosted.org/packages/d8/7a/925ff73756031289468326e355b6fa8316960d0d65f8b5d6b3a3e7866de7/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:73662edf539e72a9440129f231ed3757faab89630d291b784ca99237fb94db2b", size = 2241884 },
    { url = "https://files.pythonhosted.org/packages/0b/b0/249ee6d2646f1cdadcb813805fe76265745c4010cf20a8eba7b0e639d9b2/pydantic_core-2.33.2-cp310-cp310-win32.whl", hash = "sha256:0a39979dcbb70998b0e505fb1556a1d550a0781463ce84ebf915ba293ccb7e22", size = 1910496 },
    { url = "https://files.pythonhosted.org/packages/66/ff/172ba8f12a42d4b552917aa65d1f2328990d3ccfc01d5b7c943ec084299f/pydantic_core-2.33.2-cp310-cp310-win_amd64.whl", hash = "sha256:b0379a2b24882fef529ec3b4987cb5d003b9cda32256024e6fe1586ac45fc640", size = 1955019 },
    { url = "https://files.pythonhosted.org/packages/3f/8d/71db63483d518cbbf290261a1fc2839d17ff89fce7089e08cad07ccfce67/pydantic_core-2.33.2-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:4c5b0a576fb381edd6d27f0a85915c6daf2f8138dc5c267a57c08a62900758c7", size = 2028584 },
    { url = "https://files.pythonhosted.org/packages/24/2f/3cfa7244ae292dd850989f328722d2aef313f74ffc471184dc509e1e4e5a/pydantic_core-2.33.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:e799c050df38a639db758c617ec771fd8fb7a5f8eaaa4b27b101f266b216a246", size = 1855071 },
    { url = "https://files.pythonhosted.org/packages/b3/d3/4ae42d33f5e3f50dd467761304be2fa0a9417fbf09735bc2cce003480f2a/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:dc46a01bf8d62f227d5ecee74178ffc448ff4e5197c756331f71efcc66dc980f", size = 1897823 },
    { url = "https://files.pythonhosted.org/packages/f4/f3/aa5976e8352b7695ff808599794b1fba2a9ae2ee954a3426855935799488/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:a144d4f717285c6d9234a66778059f33a89096dfb9b39117663fd8413d582dcc", size = 1983792 },
    { url = "https://files.pythonhosted.org/packages/d5/7a/cda9b5a23c552037717f2b2a5257e9b2bfe45e687386df9591eff7b46d28/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:73cf6373c21bc80b2e0dc88444f41ae60b2f070ed02095754eb5a01df12256de", size = 2136338 },
    { url = "https://files.pythonhosted.org/packages/2b/9f/b8f9ec8dd1417eb9da784e91e1667d58a2a4a7b7b34cf4af765ef663a7e5/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:3dc625f4aa79713512d1976fe9f0bc99f706a9dee21dfd1810b4bbbf228d0e8a", size = 2730998 },
    { url = "https://files.pythonhosted.org/packages/47/bc/cd720e078576bdb8255d5032c5d63ee5c0bf4b7173dd955185a1d658c456/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:881b21b5549499972441da4758d662aeea93f1923f953e9cbaff14b8b9565aef", size = 2003200 },
    { url = "https://files.pythonhosted.org/packages/ca/22/3602b895ee2cd29d11a2b349372446ae9727c32e78a94b3d588a40fdf187/pydantic_core-2.33.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:bdc25f3681f7b78572699569514036afe3c243bc3059d3942624e936ec93450e", size = 2113890 },
    { url = "https://files.pythonhosted.org/packages/ff/e6/e3c5908c03cf00d629eb38393a98fccc38ee0ce8ecce32f69fc7d7b558a7/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:fe5b32187cbc0c862ee201ad66c30cf218e5ed468ec8dc1cf49dec66e160cc4d", size = 2073359 },
    { url = "https://files.pythonhosted.org/packages/12/e7/6a36a07c59ebefc8777d1ffdaf5ae71b06b21952582e4b07eba88a421c79/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_armv7l.whl", hash = "sha256:bc7aee6f634a6f4a95676fcb5d6559a2c2a390330098dba5e5a5f28a2e4ada30", size = 2245883 },
    { url = "https://files.pythonhosted.org/packages/16/3f/59b3187aaa6cc0c1e6616e8045b284de2b6a87b027cce2ffcea073adf1d2/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:235f45e5dbcccf6bd99f9f472858849f73d11120d76ea8707115415f8e5ebebf", size = 2241074 },
    { url = "https://files.pythonhosted.org/packages/e0/ed/55532bb88f674d5d8f67ab121a2a13c385df382de2a1677f30ad385f7438/pydantic_core-2.33.2-cp311-cp311-win32.whl", hash = "sha256:6368900c2d3ef09b69cb0b913f9f8263b03786e5b2a387706c5afb66800efd51", size = 1910538 },
    { url = "https://files.pythonhosted.org/packages/fe/1b/25b7cccd4519c0b23c2dd636ad39d381abf113085ce4f7bec2b0dc755eb1/pydantic_core-2.33.2-cp311-cp311-win_amd64.whl", hash = "sha256:1e063337ef9e9820c77acc768546325ebe04ee38b08703244c1309cccc4f1bab", size = 1952909 },
    { url = "https://files.pythonhosted.org/packages/49/a9/d809358e49126438055884c4366a1f6227f0f84f635a9014e2deb9b9de54/pydantic_core-2.33.2-cp311-cp311-win_arm64.whl", hash = "sha256:6b99022f1d19bc32a4c2a0d544fc9a76e3be90f0b3f4af413f87d38749300e65", size = 1897786 },
    { url = "https://files.pythonhosted.org/packages/18/8a/2b41c97f554ec8c71f2a8a5f85cb56a8b0956addfe8b0efb5b3d77e8bdc3/pydantic_core-2.33.2-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:a7ec89dc587667f22b6a0b6579c249fca9026ce7c333fc142ba42411fa243cdc", size = 2009000 },
    { url = "https://files.pythonhosted.org/packages/a1/02/6224312aacb3c8ecbaa959897af57181fb6cf3a3d7917fd44d0f2917e6f2/pydantic_core-2.33.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:3c6db6e52c6d70aa0d00d45cdb9b40f0433b96380071ea80b09277dba021ddf7", size = 1847996 },
    { url = "https://files.pythonhosted.org/packages/d6/46/6dcdf084a523dbe0a0be59d054734b86a981726f221f4562aed313dbcb49/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4e61206137cbc65e6d5256e1166f88331d3b6238e082d9f74613b9b765fb9025", size = 1880957 },
    { url = "https://files.pythonhosted.org/packages/ec/6b/1ec2c03837ac00886ba8160ce041ce4e325b41d06a034adbef11339ae422/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:eb8c529b2819c37140eb51b914153063d27ed88e3bdc31b71198a198e921e011", size = 1964199 },
    { url = "https://files.pythonhosted.org/packages/2d/1d/6bf34d6adb9debd9136bd197ca72642203ce9aaaa85cfcbfcf20f9696e83/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:c52b02ad8b4e2cf14ca7b3d918f3eb0ee91e63b3167c32591e57c4317e134f8f", size = 2120296 },
    { url = "https://files.pythonhosted.org/packages/e0/94/2bd0aaf5a591e974b32a9f7123f16637776c304471a0ab33cf263cf5591a/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:96081f1605125ba0855dfda83f6f3df5ec90c61195421ba72223de35ccfb2f88", size = 2676109 },
    { url = "https://files.pythonhosted.org/packages/f9/41/4b043778cf9c4285d59742281a769eac371b9e47e35f98ad321349cc5d61/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8f57a69461af2a5fa6e6bbd7a5f60d3b7e6cebb687f55106933188e79ad155c1", size = 2002028 },
    { url = "https://files.pythonhosted.org/packages/cb/d5/7bb781bf2748ce3d03af04d5c969fa1308880e1dca35a9bd94e1a96a922e/pydantic_core-2.33.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:572c7e6c8bb4774d2ac88929e3d1f12bc45714ae5ee6d9a788a9fb35e60bb04b", size = 2100044 },
    { url = "https://files.pythonhosted.org/packages/fe/36/def5e53e1eb0ad896785702a5bbfd25eed546cdcf4087ad285021a90ed53/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:db4b41f9bd95fbe5acd76d89920336ba96f03e149097365afe1cb092fceb89a1", size = 2058881 },
    { url = "https://files.pythonhosted.org/packages/01/6c/57f8d70b2ee57fc3dc8b9610315949837fa8c11d86927b9bb044f8705419/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_armv7l.whl", hash = "sha256:fa854f5cf7e33842a892e5c73f45327760bc7bc516339fda888c75ae60edaeb6", size = 2227034 },
    { url = "https://files.pythonhosted.org/packages/27/b9/9c17f0396a82b3d5cbea4c24d742083422639e7bb1d5bf600e12cb176a13/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:5f483cfb75ff703095c59e365360cb73e00185e01aaea067cd19acffd2ab20ea", size = 2234187 },
    { url = "https://files.pythonhosted.org/packages/b0/6a/adf5734ffd52bf86d865093ad70b2ce543415e0e356f6cacabbc0d9ad910/pydantic_core-2.33.2-cp312-cp312-win32.whl", hash = "sha256:9cb1da0f5a471435a7bc7e439b8a728e8b61e59784b2af70d7c169f8dd8ae290", size = 1892628 },
    { url = "https://files.pythonhosted.org/packages/43/e4/5479fecb3606c1368d496a825d8411e126133c41224c1e7238be58b87d7e/pydantic_core-2.33.2-cp312-cp312-win_amd64.whl", hash = "sha256:f941635f2a3d96b2973e867144fde513665c87f13fe0e193c158ac51bfaaa7b2", size = 1955866 },
    { url = "https://files.pythonhosted.org/packages/0d/24/8b11e8b3e2be9dd82df4b11408a67c61bb4dc4f8e11b5b0fc888b38118b5/pydantic_core-2.33.2-cp312-cp312-win_arm64.whl", hash = "sha256:cca3868ddfaccfbc4bfb1d608e2ccaaebe0ae628e1416aeb9c4d88c001bb45ab", size = 1888894 },
    { url = "https://files.pythonhosted.org/packages/46/8c/99040727b41f56616573a28771b1bfa08a3d3fe74d3d513f01251f79f172/pydantic_core-2.33.2-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:1082dd3e2d7109ad8b7da48e1d4710c8d06c253cbc4a27c1cff4fbcaa97a9e3f", size = 2015688 },
    { url = "https://files.pythonhosted.org/packages/3a/cc/5999d1eb705a6cefc31f0b4a90e9f7fc400539b1a1030529700cc1b51838/pydantic_core-2.33.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:f517ca031dfc037a9c07e748cefd8d96235088b83b4f4ba8939105d20fa1dcd6", size = 1844808 },
    { url = "https://files.pythonhosted.org/packages/6f/5e/a0a7b8885c98889a18b6e376f344da1ef323d270b44edf8174d6bce4d622/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0a9f2c9dd19656823cb8250b0724ee9c60a82f3cdf68a080979d13092a3b0fef", size = 1885580 },
    { url = "https://files.pythonhosted.org/packages/3b/2a/953581f343c7d11a304581156618c3f592435523dd9d79865903272c256a/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:2b0a451c263b01acebe51895bfb0e1cc842a5c666efe06cdf13846c7418caa9a", size = 1973859 },
    { url = "https://files.pythonhosted.org/packages/e6/55/f1a813904771c03a3f97f676c62cca0c0a4138654107c1b61f19c644868b/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:1ea40a64d23faa25e62a70ad163571c0b342b8bf66d5fa612ac0dec4f069d916", size = 2120810 },
    { url = "https://files.pythonhosted.org/packages/aa/c3/053389835a996e18853ba107a63caae0b9deb4a276c6b472931ea9ae6e48/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:0fb2d542b4d66f9470e8065c5469ec676978d625a8b7a363f07d9a501a9cb36a", size = 2676498 },
    { url = "https://files.pythonhosted.org/packages/eb/3c/f4abd740877a35abade05e437245b192f9d0ffb48bbbbd708df33d3cda37/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9fdac5d6ffa1b5a83bca06ffe7583f5576555e6c8b3a91fbd25ea7780f825f7d", size = 2000611 },
    { url = "https://files.pythonhosted.org/packages/59/a7/63ef2fed1837d1121a894d0ce88439fe3e3b3e48c7543b2a4479eb99c2bd/pydantic_core-2.33.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:04a1a413977ab517154eebb2d326da71638271477d6ad87a769102f7c2488c56", size = 2107924 },
    { url = "https://files.pythonhosted.org/packages/04/8f/2551964ef045669801675f1cfc3b0d74147f4901c3ffa42be2ddb1f0efc4/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:c8e7af2f4e0194c22b5b37205bfb293d166a7344a5b0d0eaccebc376546d77d5", size = 2063196 },
    { url = "https://files.pythonhosted.org/packages/26/bd/d9602777e77fc6dbb0c7db9ad356e9a985825547dce5ad1d30ee04903918/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_armv7l.whl", hash = "sha256:5c92edd15cd58b3c2d34873597a1e20f13094f59cf88068adb18947df5455b4e", size = 2236389 },
    { url = "https://files.pythonhosted.org/packages/42/db/0e950daa7e2230423ab342ae918a794964b053bec24ba8af013fc7c94846/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:65132b7b4a1c0beded5e057324b7e16e10910c106d43675d9bd87d4f38dde162", size = 2239223 },
    { url = "https://files.pythonhosted.org/packages/58/4d/4f937099c545a8a17eb52cb67fe0447fd9a373b348ccfa9a87f141eeb00f/pydantic_core-2.33.2-cp313-cp313-win32.whl", hash = "sha256:52fb90784e0a242bb96ec53f42196a17278855b0f31ac7c3cc6f5c1ec4811849", size = 1900473 },
    { url = "https://files.pythonhosted.org/packages/a0/75/4a0a9bac998d78d889def5e4ef2b065acba8cae8c93696906c3a91f310ca/pydantic_core-2.33.2-cp313-cp313-win_amd64.whl", hash = "sha256:c083a3bdd5a93dfe480f1125926afcdbf2917ae714bdb80b36d34318b2bec5d9", size = 1955269 },
    { url = "https://files.pythonhosted.org/packages/f9/86/1beda0576969592f1497b4ce8e7bc8cbdf614c352426271b1b10d5f0aa64/pydantic_core-2.33.2-cp313-cp313-win_arm64.whl", hash = "sha256:e80b087132752f6b3d714f041ccf74403799d3b23a72722ea2e6ba2e892555b9", size = 1893921 },
    { url = "https://files.pythonhosted.org/packages/a4/7d/e09391c2eebeab681df2b74bfe6c43422fffede8dc74187b2b0bf6fd7571/pydantic_core-2.33.2-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:61c18fba8e5e9db3ab908620af374db0ac1baa69f0f32df4f61ae23f15e586ac", size = 1806162 },
    { url = "https://files.pythonhosted.org/packages/f1/3d/847b6b1fed9f8ed3bb95a9ad04fbd0b212e832d4f0f50ff4d9ee5a9f15cf/pydantic_core-2.33.2-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:95237e53bb015f67b63c91af7518a62a8660376a6a0db19b89acc77a4d6199f5", size = 1981560 },
    { url = "https://files.pythonhosted.org/packages/6f/9a/e73262f6c6656262b5fdd723ad90f518f579b7bc8622e43a942eec53c938/pydantic_core-2.33.2-cp313-cp313t-win_amd64.whl", hash = "sha256:c2fc0a768ef76c15ab9238afa6da7f69895bb5d1ee83aeea2e3509af4472d0b9", size = 1935777 },
    { url = "https://files.pythonhosted.org/packages/30/68/373d55e58b7e83ce371691f6eaa7175e3a24b956c44628eb25d7da007917/pydantic_core-2.33.2-pp310-pypy310_pp73-macosx_10_12_x86_64.whl", hash = "sha256:5c4aa4e82353f65e548c476b37e64189783aa5384903bfea4f41580f255fddfa", size = 2023982 },
    { url = "https://files.pythonhosted.org/packages/a4/16/145f54ac08c96a63d8ed6442f9dec17b2773d19920b627b18d4f10a061ea/pydantic_core-2.33.2-pp310-pypy310_pp73-macosx_11_0_arm64.whl", hash = "sha256:d946c8bf0d5c24bf4fe333af284c59a19358aa3ec18cb3dc4370080da1e8ad29", size = 1858412 },
    { url = "https://files.pythonhosted.org/packages/41/b1/c6dc6c3e2de4516c0bb2c46f6a373b91b5660312342a0cf5826e38ad82fa/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:87b31b6846e361ef83fedb187bb5b4372d0da3f7e28d85415efa92d6125d6e6d", size = 1892749 },
    { url = "https://files.pythonhosted.org/packages/12/73/8cd57e20afba760b21b742106f9dbdfa6697f1570b189c7457a1af4cd8a0/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:aa9d91b338f2df0508606f7009fde642391425189bba6d8c653afd80fd6bb64e", size = 2067527 },
    { url = "https://files.pythonhosted.org/packages/e3/d5/0bb5d988cc019b3cba4a78f2d4b3854427fc47ee8ec8e9eaabf787da239c/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:2058a32994f1fde4ca0480ab9d1e75a0e8c87c22b53a3ae66554f9af78f2fe8c", size = 2108225 },
    { url = "https://files.pythonhosted.org/packages/f1/c5/00c02d1571913d496aabf146106ad8239dc132485ee22efe08085084ff7c/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:0e03262ab796d986f978f79c943fc5f620381be7287148b8010b4097f79a39ec", size = 2069490 },
    { url = "https://files.pythonhosted.org/packages/22/a8/dccc38768274d3ed3a59b5d06f59ccb845778687652daa71df0cab4040d7/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:1a8695a8d00c73e50bff9dfda4d540b7dee29ff9b8053e38380426a85ef10052", size = 2237525 },
    { url = "https://files.pythonhosted.org/packages/d4/e7/4f98c0b125dda7cf7ccd14ba936218397b44f50a56dd8c16a3091df116c3/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:fa754d1850735a0b0e03bcffd9d4b4343eb417e47196e4485d9cca326073a42c", size = 2238446 },
    { url = "https://files.pythonhosted.org/packages/ce/91/2ec36480fdb0b783cd9ef6795753c1dea13882f2e68e73bce76ae8c21e6a/pydantic_core-2.33.2-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:a11c8d26a50bfab49002947d3d237abe4d9e4b5bdc8846a63537b6488e197808", size = 2066678 },
    { url = "https://files.pythonhosted.org/packages/7b/27/d4ae6487d73948d6f20dddcd94be4ea43e74349b56eba82e9bdee2d7494c/pydantic_core-2.33.2-pp311-pypy311_pp73-macosx_10_12_x86_64.whl", hash = "sha256:dd14041875d09cc0f9308e37a6f8b65f5585cf2598a53aa0123df8b129d481f8", size = 2025200 },
    { url = "https://files.pythonhosted.org/packages/f1/b8/b3cb95375f05d33801024079b9392a5ab45267a63400bf1866e7ce0f0de4/pydantic_core-2.33.2-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:d87c561733f66531dced0da6e864f44ebf89a8fba55f31407b00c2f7f9449593", size = 1859123 },
    { url = "https://files.pythonhosted.org/packages/05/bc/0d0b5adeda59a261cd30a1235a445bf55c7e46ae44aea28f7bd6ed46e091/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:2f82865531efd18d6e07a04a17331af02cb7a651583c418df8266f17a63c6612", size = 1892852 },
    { url = "https://files.pythonhosted.org/packages/3e/11/d37bdebbda2e449cb3f519f6ce950927b56d62f0b84fd9cb9e372a26a3d5/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:2bfb5112df54209d820d7bf9317c7a6c9025ea52e49f46b6a2060104bba37de7", size = 2067484 },
    { url = "https://files.pythonhosted.org/packages/8c/55/1f95f0a05ce72ecb02a8a8a1c3be0579bbc29b1d5ab68f1378b7bebc5057/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:64632ff9d614e5eecfb495796ad51b0ed98c453e447a76bcbeeb69615079fc7e", size = 2108896 },
    { url = "https://files.pythonhosted.org/packages/53/89/2b2de6c81fa131f423246a9109d7b2a375e83968ad0800d6e57d0574629b/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:f889f7a40498cc077332c7ab6b4608d296d852182211787d4f3ee377aaae66e8", size = 2069475 },
    { url = "https://files.pythonhosted.org/packages/b8/e9/1f7efbe20d0b2b10f6718944b5d8ece9152390904f29a78e68d4e7961159/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:de4b83bb311557e439b9e186f733f6c645b9417c84e2eb8203f3f820a4b988bf", size = 2239013 },
    { url = "https://files.pythonhosted.org/packages/3c/b2/5309c905a93811524a49b4e031e9851a6b00ff0fb668794472ea7746b448/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:82f68293f055f51b51ea42fafc74b6aad03e70e191799430b90c13d643059ebb", size = 2238715 },
    { url = "https://files.pythonhosted.org/packages/32/56/8a7ca5d2cd2cda1d245d34b1c9a942920a718082ae8e54e5f3e5a58b7add/pydantic_core-2.33.2-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:329467cecfb529c925cf2bbd4d60d2c509bc2fb52a20c1045bf09bb70971a9c1", size = 2066757 },
]

[[package]]
name = "pydantic-settings"
version = "2.9.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pydantic" },
    { name = "python-dotenv" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/67/1d/42628a2c33e93f8e9acbde0d5d735fa0850f3e6a2f8cb1eb6c40b9a732ac/pydantic_settings-2.9.1.tar.gz", hash = "sha256:c509bf79d27563add44e8446233359004ed85066cd096d8b510f715e6ef5d268", size = 163234 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b6/5f/d6d641b490fd3ec2c4c13b4244d68deea3a1b970a97be64f34fb5504ff72/pydantic_settings-2.9.1-py3-none-any.whl", hash = "sha256:59b4f431b1defb26fe620c71a7d3968a710d719f5f4cdbbdb7926edeb770f6ef", size = 44356 },
]

[[package]]
name = "pygments"
version = "2.19.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/7c/2d/c3338d48ea6cc0feb8446d8e6937e1408088a72a39937982cc6111d17f84/pygments-2.19.1.tar.gz", hash = "sha256:61c16d2a8576dc0649d9f39e089b5f02bcd27fba10d8fb4dcc28173f7a45151f", size = 4968581 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8a/0b/9fcc47d19c48b59121088dd6da2488a49d5f72dacf8262e2790a1d2c7d15/pygments-2.19.1-py3-none-any.whl", hash = "sha256:9ea1544ad55cecf4b8242fab6dd35a93bbce657034b0611ee383099054ab6d8c", size = 1225293 },
]

[[package]]
name = "python-dotenv"
version = "1.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/88/2c/7bb1416c5620485aa793f2de31d3df393d3686aa8a8506d11e10e13c5baf/python_dotenv-1.1.0.tar.gz", hash = "sha256:41f90bc6f5f177fb41f53e87666db362025010eb28f60a01c9143bfa33a2b2d5", size = 39920 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1e/18/98a99ad95133c6a6e2005fe89faedf294a748bd5dc803008059409ac9b1e/python_dotenv-1.1.0-py3-none-any.whl", hash = "sha256:d7c01d9e2293916c18baf562d95698754b0dbbb5e74d457c45d4f6561fb9d55d", size = 20256 },
]

[[package]]
name = "python-multipart"
version = "0.0.20"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f3/87/f44d7c9f274c7ee665a29b885ec97089ec5dc034c7f3fafa03da9e39a09e/python_multipart-0.0.20.tar.gz", hash = "sha256:8dd0cab45b8e23064ae09147625994d090fa46f5b0d1e13af944c331a7fa9d13", size = 37158 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/45/58/38b5afbc1a800eeea951b9285d3912613f2603bdf897a4ab0f4bd7f405fc/python_multipart-0.0.20-py3-none-any.whl", hash = "sha256:8a62d3a8335e06589fe01f2a3e178cdcc632f3fbe0d492ad9ee0ec35aab1f104", size = 24546 },
]

[[package]]
name = "rich"
version = "14.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markdown-it-py" },
    { name = "pygments" },
    { name = "typing-extensions", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/a1/53/830aa4c3066a8ab0ae9a9955976fb770fe9c6102117c8ec4ab3ea62d89e8/rich-14.0.0.tar.gz", hash = "sha256:82f1bc23a6a21ebca4ae0c45af9bdbc492ed20231dcb63f297d6d1021a9d5725", size = 224078 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0d/9b/63f4c7ebc259242c89b3acafdb37b41d1185c07ff0011164674e9076b491/rich-14.0.0-py3-none-any.whl", hash = "sha256:1c9491e1951aac09caffd42f448ee3d04e58923ffe14993f6e83068dc395d7e0", size = 243229 },
]

[[package]]
name = "shellingham"
version = "1.5.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/58/15/8b3609fd3830ef7b27b655beb4b4e9c62313a4e8da8c676e142cc210d58e/shellingham-1.5.4.tar.gz", hash = "sha256:8dbca0739d487e5bd35ab3ca4b36e11c4078f3a234bfce294b0a0291363404de", size = 10310 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e0/f9/0595336914c5619e5f28a1fb793285925a8cd4b432c9da0a987836c7f822/shellingham-1.5.4-py2.py3-none-any.whl", hash = "sha256:7ecfff8f2fd72616f7481040475a65b2bf8af90a56c89140852d1120324e8686", size = 9755 },
]

[[package]]
name = "sniffio"
version = "1.3.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a2/87/a6771e1546d97e7e041b6ae58d80074f81b7d5121207425c964ddf5cfdbd/sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc", size = 20372 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e9/44/75a9c9421471a6c4805dbf2356f7c181a29c1879239abab1ea2cc8f38b40/sniffio-1.3.1-py3-none-any.whl", hash = "sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2", size = 10235 },
]

[[package]]
name = "sse-starlette"
version = "2.3.5"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "starlette" },
]
sdist = { url = "https://files.pythonhosted.org/packages/10/5f/28f45b1ff14bee871bacafd0a97213f7ec70e389939a80c60c0fb72a9fc9/sse_starlette-2.3.5.tar.gz", hash = "sha256:228357b6e42dcc73a427990e2b4a03c023e2495ecee82e14f07ba15077e334b2", size = 17511 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c8/48/3e49cf0f64961656402c0023edbc51844fe17afe53ab50e958a6dbbbd499/sse_starlette-2.3.5-py3-none-any.whl", hash = "sha256:251708539a335570f10eaaa21d1848a10c42ee6dc3a9cf37ef42266cdb1c52a8", size = 10233 },
]

[[package]]
name = "starlette"
version = "0.46.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ce/20/08dfcd9c983f6a6f4a1000d934b9e6d626cff8d2eeb77a89a68eef20a2b7/starlette-0.46.2.tar.gz", hash = "sha256:7f7361f34eed179294600af672f565727419830b54b7b084efe44bb82d2fccd5", size = 2580846 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8b/0c/9d30a4ebeb6db2b25a841afbb80f6ef9a854fc3b41be131d249a977b4959/starlette-0.46.2-py3-none-any.whl", hash = "sha256:595633ce89f8ffa71a015caed34a5b2dc1c0cdb3f0f1fbd1e69339cf2abeec35", size = 72037 },
]

[[package]]
name = "typer"
version = "0.15.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "rich" },
    { name = "shellingham" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6c/89/c527e6c848739be8ceb5c44eb8208c52ea3515c6cf6406aa61932887bf58/typer-0.15.4.tar.gz", hash = "sha256:89507b104f9b6a0730354f27c39fae5b63ccd0c95b1ce1f1a6ba0cfd329997c3", size = 101559 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c9/62/d4ba7afe2096d5659ec3db8b15d8665bdcb92a3c6ff0b95e99895b335a9c/typer-0.15.4-py3-none-any.whl", hash = "sha256:eb0651654dcdea706780c466cf06d8f174405a659ffff8f163cfbfee98c0e173", size = 45258 },
]

[[package]]
name = "typing-extensions"
version = "4.13.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f6/37/23083fcd6e35492953e8d2aaaa68b860eb422b34627b13f2ce3eb6106061/typing_extensions-4.13.2.tar.gz", hash = "sha256:e6c81219bd689f51865d9e372991c540bda33a0379d5573cddb9a3a23f7caaef", size = 106967 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8b/54/b1ae86c0973cc6f0210b53d508ca3641fb6d0c56823f288d108bc7ab3cc8/typing_extensions-4.13.2-py3-none-any.whl", hash = "sha256:a439e7c04b49fec3e5d3e2beaa21755cadbbdc391694e28ccdd36ca4a1408f8c", size = 45806 },
]

[[package]]
name = "typing-inspection"
version = "0.4.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/82/5c/e6082df02e215b846b4b8c0b887a64d7d08ffaba30605502639d44c06b82/typing_inspection-0.4.0.tar.gz", hash = "sha256:9765c87de36671694a67904bf2c96e395be9c6439bb6c87b5142569dcdd65122", size = 76222 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/31/08/aa4fdfb71f7de5176385bd9e90852eaf6b5d622735020ad600f2bab54385/typing_inspection-0.4.0-py3-none-any.whl", hash = "sha256:50e72559fcd2a6367a19f7a7e610e6afcb9fac940c650290eed893d61386832f", size = 14125 },
]

[[package]]
name = "uvicorn"
version = "0.34.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "h11" },
    { name = "typing-extensions", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/a6/ae/9bbb19b9e1c450cf9ecaef06463e40234d98d95bf572fab11b4f19ae5ded/uvicorn-0.34.2.tar.gz", hash = "sha256:0e929828f6186353a80b58ea719861d2629d766293b6d19baf086ba31d4f3328", size = 76815 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b1/4b/4cef6ce21a2aaca9d852a6e84ef4f135d99fcd74fa75105e2fc0c8308acd/uvicorn-0.34.2-py3-none-any.whl", hash = "sha256:deb49af569084536d269fe0a6d67e3754f104cf03aba7c11c40f01aadf33c403", size = 62483 },
]

[[package]]
name = "wrapt"
version = "1.17.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/c3/fc/e91cc220803d7bc4db93fb02facd8461c37364151b8494762cc88b0fbcef/wrapt-1.17.2.tar.gz", hash = "sha256:41388e9d4d1522446fe79d3213196bd9e3b301a336965b9e27ca2788ebd122f3", size = 55531 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/5a/d1/1daec934997e8b160040c78d7b31789f19b122110a75eca3d4e8da0049e1/wrapt-1.17.2-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:3d57c572081fed831ad2d26fd430d565b76aa277ed1d30ff4d40670b1c0dd984", size = 53307 },
    { url = "https://files.pythonhosted.org/packages/1b/7b/13369d42651b809389c1a7153baa01d9700430576c81a2f5c5e460df0ed9/wrapt-1.17.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:b5e251054542ae57ac7f3fba5d10bfff615b6c2fb09abeb37d2f1463f841ae22", size = 38486 },
    { url = "https://files.pythonhosted.org/packages/62/bf/e0105016f907c30b4bd9e377867c48c34dc9c6c0c104556c9c9126bd89ed/wrapt-1.17.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:80dd7db6a7cb57ffbc279c4394246414ec99537ae81ffd702443335a61dbf3a7", size = 38777 },
    { url = "https://files.pythonhosted.org/packages/27/70/0f6e0679845cbf8b165e027d43402a55494779295c4b08414097b258ac87/wrapt-1.17.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0a6e821770cf99cc586d33833b2ff32faebdbe886bd6322395606cf55153246c", size = 83314 },
    { url = "https://files.pythonhosted.org/packages/0f/77/0576d841bf84af8579124a93d216f55d6f74374e4445264cb378a6ed33eb/wrapt-1.17.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:b60fb58b90c6d63779cb0c0c54eeb38941bae3ecf7a73c764c52c88c2dcb9d72", size = 74947 },
    { url = "https://files.pythonhosted.org/packages/90/ec/00759565518f268ed707dcc40f7eeec38637d46b098a1f5143bff488fe97/wrapt-1.17.2-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:b870b5df5b71d8c3359d21be8f0d6c485fa0ebdb6477dda51a1ea54a9b558061", size = 82778 },
    { url = "https://files.pythonhosted.org/packages/f8/5a/7cffd26b1c607b0b0c8a9ca9d75757ad7620c9c0a9b4a25d3f8a1480fafc/wrapt-1.17.2-cp310-cp310-musllinux_1_2_aarch64.whl", hash = "sha256:4011d137b9955791f9084749cba9a367c68d50ab8d11d64c50ba1688c9b457f2", size = 81716 },
    { url = "https://files.pythonhosted.org/packages/7e/09/dccf68fa98e862df7e6a60a61d43d644b7d095a5fc36dbb591bbd4a1c7b2/wrapt-1.17.2-cp310-cp310-musllinux_1_2_i686.whl", hash = "sha256:1473400e5b2733e58b396a04eb7f35f541e1fb976d0c0724d0223dd607e0f74c", size = 74548 },
    { url = "https://files.pythonhosted.org/packages/b7/8e/067021fa3c8814952c5e228d916963c1115b983e21393289de15128e867e/wrapt-1.17.2-cp310-cp310-musllinux_1_2_x86_64.whl", hash = "sha256:3cedbfa9c940fdad3e6e941db7138e26ce8aad38ab5fe9dcfadfed9db7a54e62", size = 81334 },
    { url = "https://files.pythonhosted.org/packages/4b/0d/9d4b5219ae4393f718699ca1c05f5ebc0c40d076f7e65fd48f5f693294fb/wrapt-1.17.2-cp310-cp310-win32.whl", hash = "sha256:582530701bff1dec6779efa00c516496968edd851fba224fbd86e46cc6b73563", size = 36427 },
    { url = "https://files.pythonhosted.org/packages/72/6a/c5a83e8f61aec1e1aeef939807602fb880e5872371e95df2137142f5c58e/wrapt-1.17.2-cp310-cp310-win_amd64.whl", hash = "sha256:58705da316756681ad3c9c73fd15499aa4d8c69f9fd38dc8a35e06c12468582f", size = 38774 },
    { url = "https://files.pythonhosted.org/packages/cd/f7/a2aab2cbc7a665efab072344a8949a71081eed1d2f451f7f7d2b966594a2/wrapt-1.17.2-cp311-cp311-macosx_10_9_universal2.whl", hash = "sha256:ff04ef6eec3eee8a5efef2401495967a916feaa353643defcc03fc74fe213b58", size = 53308 },
    { url = "https://files.pythonhosted.org/packages/50/ff/149aba8365fdacef52b31a258c4dc1c57c79759c335eff0b3316a2664a64/wrapt-1.17.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:4db983e7bca53819efdbd64590ee96c9213894272c776966ca6306b73e4affda", size = 38488 },
    { url = "https://files.pythonhosted.org/packages/65/46/5a917ce85b5c3b490d35c02bf71aedaa9f2f63f2d15d9949cc4ba56e8ba9/wrapt-1.17.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:9abc77a4ce4c6f2a3168ff34b1da9b0f311a8f1cfd694ec96b0603dff1c79438", size = 38776 },
    { url = "https://files.pythonhosted.org/packages/ca/74/336c918d2915a4943501c77566db41d1bd6e9f4dbc317f356b9a244dfe83/wrapt-1.17.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0b929ac182f5ace000d459c59c2c9c33047e20e935f8e39371fa6e3b85d56f4a", size = 83776 },
    { url = "https://files.pythonhosted.org/packages/09/99/c0c844a5ccde0fe5761d4305485297f91d67cf2a1a824c5f282e661ec7ff/wrapt-1.17.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:f09b286faeff3c750a879d336fb6d8713206fc97af3adc14def0cdd349df6000", size = 75420 },
    { url = "https://files.pythonhosted.org/packages/b4/b0/9fc566b0fe08b282c850063591a756057c3247b2362b9286429ec5bf1721/wrapt-1.17.2-cp311-cp311-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:1a7ed2d9d039bd41e889f6fb9364554052ca21ce823580f6a07c4ec245c1f5d6", size = 83199 },
    { url = "https://files.pythonhosted.org/packages/9d/4b/71996e62d543b0a0bd95dda485219856def3347e3e9380cc0d6cf10cfb2f/wrapt-1.17.2-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:129a150f5c445165ff941fc02ee27df65940fcb8a22a61828b1853c98763a64b", size = 82307 },
    { url = "https://files.pythonhosted.org/packages/39/35/0282c0d8789c0dc9bcc738911776c762a701f95cfe113fb8f0b40e45c2b9/wrapt-1.17.2-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:1fb5699e4464afe5c7e65fa51d4f99e0b2eadcc176e4aa33600a3df7801d6662", size = 75025 },
    { url = "https://files.pythonhosted.org/packages/4f/6d/90c9fd2c3c6fee181feecb620d95105370198b6b98a0770cba090441a828/wrapt-1.17.2-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:9a2bce789a5ea90e51a02dfcc39e31b7f1e662bc3317979aa7e5538e3a034f72", size = 81879 },
    { url = "https://files.pythonhosted.org/packages/8f/fa/9fb6e594f2ce03ef03eddbdb5f4f90acb1452221a5351116c7c4708ac865/wrapt-1.17.2-cp311-cp311-win32.whl", hash = "sha256:4afd5814270fdf6380616b321fd31435a462019d834f83c8611a0ce7484c7317", size = 36419 },
    { url = "https://files.pythonhosted.org/packages/47/f8/fb1773491a253cbc123c5d5dc15c86041f746ed30416535f2a8df1f4a392/wrapt-1.17.2-cp311-cp311-win_amd64.whl", hash = "sha256:acc130bc0375999da18e3d19e5a86403667ac0c4042a094fefb7eec8ebac7cf3", size = 38773 },
    { url = "https://files.pythonhosted.org/packages/a1/bd/ab55f849fd1f9a58ed7ea47f5559ff09741b25f00c191231f9f059c83949/wrapt-1.17.2-cp312-cp312-macosx_10_13_universal2.whl", hash = "sha256:d5e2439eecc762cd85e7bd37161d4714aa03a33c5ba884e26c81559817ca0925", size = 53799 },
    { url = "https://files.pythonhosted.org/packages/53/18/75ddc64c3f63988f5a1d7e10fb204ffe5762bc663f8023f18ecaf31a332e/wrapt-1.17.2-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:3fc7cb4c1c744f8c05cd5f9438a3caa6ab94ce8344e952d7c45a8ed59dd88392", size = 38821 },
    { url = "https://files.pythonhosted.org/packages/48/2a/97928387d6ed1c1ebbfd4efc4133a0633546bec8481a2dd5ec961313a1c7/wrapt-1.17.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8fdbdb757d5390f7c675e558fd3186d590973244fab0c5fe63d373ade3e99d40", size = 38919 },
    { url = "https://files.pythonhosted.org/packages/73/54/3bfe5a1febbbccb7a2f77de47b989c0b85ed3a6a41614b104204a788c20e/wrapt-1.17.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:5bb1d0dbf99411f3d871deb6faa9aabb9d4e744d67dcaaa05399af89d847a91d", size = 88721 },
    { url = "https://files.pythonhosted.org/packages/25/cb/7262bc1b0300b4b64af50c2720ef958c2c1917525238d661c3e9a2b71b7b/wrapt-1.17.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:d18a4865f46b8579d44e4fe1e2bcbc6472ad83d98e22a26c963d46e4c125ef0b", size = 80899 },
    { url = "https://files.pythonhosted.org/packages/2a/5a/04cde32b07a7431d4ed0553a76fdb7a61270e78c5fd5a603e190ac389f14/wrapt-1.17.2-cp312-cp312-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:bc570b5f14a79734437cb7b0500376b6b791153314986074486e0b0fa8d71d98", size = 89222 },
    { url = "https://files.pythonhosted.org/packages/09/28/2e45a4f4771fcfb109e244d5dbe54259e970362a311b67a965555ba65026/wrapt-1.17.2-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:6d9187b01bebc3875bac9b087948a2bccefe464a7d8f627cf6e48b1bbae30f82", size = 86707 },
    { url = "https://files.pythonhosted.org/packages/c6/d2/dcb56bf5f32fcd4bd9aacc77b50a539abdd5b6536872413fd3f428b21bed/wrapt-1.17.2-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:9e8659775f1adf02eb1e6f109751268e493c73716ca5761f8acb695e52a756ae", size = 79685 },
    { url = "https://files.pythonhosted.org/packages/80/4e/eb8b353e36711347893f502ce91c770b0b0929f8f0bed2670a6856e667a9/wrapt-1.17.2-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:e8b2816ebef96d83657b56306152a93909a83f23994f4b30ad4573b00bd11bb9", size = 87567 },
    { url = "https://files.pythonhosted.org/packages/17/27/4fe749a54e7fae6e7146f1c7d914d28ef599dacd4416566c055564080fe2/wrapt-1.17.2-cp312-cp312-win32.whl", hash = "sha256:468090021f391fe0056ad3e807e3d9034e0fd01adcd3bdfba977b6fdf4213ea9", size = 36672 },
    { url = "https://files.pythonhosted.org/packages/15/06/1dbf478ea45c03e78a6a8c4be4fdc3c3bddea5c8de8a93bc971415e47f0f/wrapt-1.17.2-cp312-cp312-win_amd64.whl", hash = "sha256:ec89ed91f2fa8e3f52ae53cd3cf640d6feff92ba90d62236a81e4e563ac0e991", size = 38865 },
    { url = "https://files.pythonhosted.org/packages/ce/b9/0ffd557a92f3b11d4c5d5e0c5e4ad057bd9eb8586615cdaf901409920b14/wrapt-1.17.2-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:6ed6ffac43aecfe6d86ec5b74b06a5be33d5bb9243d055141e8cabb12aa08125", size = 53800 },
    { url = "https://files.pythonhosted.org/packages/c0/ef/8be90a0b7e73c32e550c73cfb2fa09db62234227ece47b0e80a05073b375/wrapt-1.17.2-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:35621ae4c00e056adb0009f8e86e28eb4a41a4bfa8f9bfa9fca7d343fe94f998", size = 38824 },
    { url = "https://files.pythonhosted.org/packages/36/89/0aae34c10fe524cce30fe5fc433210376bce94cf74d05b0d68344c8ba46e/wrapt-1.17.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:a604bf7a053f8362d27eb9fefd2097f82600b856d5abe996d623babd067b1ab5", size = 38920 },
    { url = "https://files.pythonhosted.org/packages/3b/24/11c4510de906d77e0cfb5197f1b1445d4fec42c9a39ea853d482698ac681/wrapt-1.17.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:5cbabee4f083b6b4cd282f5b817a867cf0b1028c54d445b7ec7cfe6505057cf8", size = 88690 },
    { url = "https://files.pythonhosted.org/packages/71/d7/cfcf842291267bf455b3e266c0c29dcb675b5540ee8b50ba1699abf3af45/wrapt-1.17.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:49703ce2ddc220df165bd2962f8e03b84c89fee2d65e1c24a7defff6f988f4d6", size = 80861 },
    { url = "https://files.pythonhosted.org/packages/d5/66/5d973e9f3e7370fd686fb47a9af3319418ed925c27d72ce16b791231576d/wrapt-1.17.2-cp313-cp313-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8112e52c5822fc4253f3901b676c55ddf288614dc7011634e2719718eaa187dc", size = 89174 },
    { url = "https://files.pythonhosted.org/packages/a7/d3/8e17bb70f6ae25dabc1aaf990f86824e4fd98ee9cadf197054e068500d27/wrapt-1.17.2-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:9fee687dce376205d9a494e9c121e27183b2a3df18037f89d69bd7b35bcf59e2", size = 86721 },
    { url = "https://files.pythonhosted.org/packages/6f/54/f170dfb278fe1c30d0ff864513cff526d624ab8de3254b20abb9cffedc24/wrapt-1.17.2-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:18983c537e04d11cf027fbb60a1e8dfd5190e2b60cc27bc0808e653e7b218d1b", size = 79763 },
    { url = "https://files.pythonhosted.org/packages/4a/98/de07243751f1c4a9b15c76019250210dd3486ce098c3d80d5f729cba029c/wrapt-1.17.2-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:703919b1633412ab54bcf920ab388735832fdcb9f9a00ae49387f0fe67dad504", size = 87585 },
    { url = "https://files.pythonhosted.org/packages/f9/f0/13925f4bd6548013038cdeb11ee2cbd4e37c30f8bfd5db9e5a2a370d6e20/wrapt-1.17.2-cp313-cp313-win32.whl", hash = "sha256:abbb9e76177c35d4e8568e58650aa6926040d6a9f6f03435b7a522bf1c487f9a", size = 36676 },
    { url = "https://files.pythonhosted.org/packages/bf/ae/743f16ef8c2e3628df3ddfd652b7d4c555d12c84b53f3d8218498f4ade9b/wrapt-1.17.2-cp313-cp313-win_amd64.whl", hash = "sha256:69606d7bb691b50a4240ce6b22ebb319c1cfb164e5f6569835058196e0f3a845", size = 38871 },
    { url = "https://files.pythonhosted.org/packages/3d/bc/30f903f891a82d402ffb5fda27ec1d621cc97cb74c16fea0b6141f1d4e87/wrapt-1.17.2-cp313-cp313t-macosx_10_13_universal2.whl", hash = "sha256:4a721d3c943dae44f8e243b380cb645a709ba5bd35d3ad27bc2ed947e9c68192", size = 56312 },
    { url = "https://files.pythonhosted.org/packages/8a/04/c97273eb491b5f1c918857cd26f314b74fc9b29224521f5b83f872253725/wrapt-1.17.2-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:766d8bbefcb9e00c3ac3b000d9acc51f1b399513f44d77dfe0eb026ad7c9a19b", size = 40062 },
    { url = "https://files.pythonhosted.org/packages/4e/ca/3b7afa1eae3a9e7fefe499db9b96813f41828b9fdb016ee836c4c379dadb/wrapt-1.17.2-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:e496a8ce2c256da1eb98bd15803a79bee00fc351f5dfb9ea82594a3f058309e0", size = 40155 },
    { url = "https://files.pythonhosted.org/packages/89/be/7c1baed43290775cb9030c774bc53c860db140397047cc49aedaf0a15477/wrapt-1.17.2-cp313-cp313t-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:40d615e4fe22f4ad3528448c193b218e077656ca9ccb22ce2cb20db730f8d306", size = 113471 },
    { url = "https://files.pythonhosted.org/packages/32/98/4ed894cf012b6d6aae5f5cc974006bdeb92f0241775addad3f8cd6ab71c8/wrapt-1.17.2-cp313-cp313t-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:a5aaeff38654462bc4b09023918b7f21790efb807f54c000a39d41d69cf552cb", size = 101208 },
    { url = "https://files.pythonhosted.org/packages/ea/fd/0c30f2301ca94e655e5e057012e83284ce8c545df7661a78d8bfca2fac7a/wrapt-1.17.2-cp313-cp313t-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9a7d15bbd2bc99e92e39f49a04653062ee6085c0e18b3b7512a4f2fe91f2d681", size = 109339 },
    { url = "https://files.pythonhosted.org/packages/75/56/05d000de894c4cfcb84bcd6b1df6214297b8089a7bd324c21a4765e49b14/wrapt-1.17.2-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:e3890b508a23299083e065f435a492b5435eba6e304a7114d2f919d400888cc6", size = 110232 },
    { url = "https://files.pythonhosted.org/packages/53/f8/c3f6b2cf9b9277fb0813418e1503e68414cd036b3b099c823379c9575e6d/wrapt-1.17.2-cp313-cp313t-musllinux_1_2_i686.whl", hash = "sha256:8c8b293cd65ad716d13d8dd3624e42e5a19cc2a2f1acc74b30c2c13f15cb61a6", size = 100476 },
    { url = "https://files.pythonhosted.org/packages/a7/b1/0bb11e29aa5139d90b770ebbfa167267b1fc548d2302c30c8f7572851738/wrapt-1.17.2-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:4c82b8785d98cdd9fed4cac84d765d234ed3251bd6afe34cb7ac523cb93e8b4f", size = 106377 },
    { url = "https://files.pythonhosted.org/packages/6a/e1/0122853035b40b3f333bbb25f1939fc1045e21dd518f7f0922b60c156f7c/wrapt-1.17.2-cp313-cp313t-win32.whl", hash = "sha256:13e6afb7fe71fe7485a4550a8844cc9ffbe263c0f1a1eea569bc7091d4898555", size = 37986 },
    { url = "https://files.pythonhosted.org/packages/09/5e/1655cf481e079c1f22d0cabdd4e51733679932718dc23bf2db175f329b76/wrapt-1.17.2-cp313-cp313t-win_amd64.whl", hash = "sha256:eaf675418ed6b3b31c7a989fd007fa7c3be66ce14e5c3b27336383604c9da85c", size = 40750 },
    { url = "https://files.pythonhosted.org/packages/2d/82/f56956041adef78f849db6b289b282e72b55ab8045a75abad81898c28d19/wrapt-1.17.2-py3-none-any.whl", hash = "sha256:b18f2d1533a71f069c7f82d524a52599053d4c7166e9dd374ae2136b7f40f7c8", size = 23594 },
]

[[package]]
name = "xyte-mcp-alpha"
version = "1.1.0"
source = { editable = "." }
dependencies = [
    { name = "cachetools" },
    { name = "httpx" },
    { name = "mcp", extra = ["cli"] },
    { name = "opentelemetry-sdk" },
    { name = "prometheus-client" },
    { name = "pydantic" },
    { name = "python-dotenv" },
]

[package.metadata]
requires-dist = [
    { name = "cachetools", specifier = ">=5.3.0" },
    { name = "httpx", specifier = ">=0.27.0" },
    { name = "mcp", extras = ["cli"], specifier = ">=1.1.0" },
    { name = "opentelemetry-sdk", specifier = ">=1.22.0" },
    { name = "prometheus-client", specifier = ">=0.19.0" },
    { name = "pydantic", specifier = ">=2.0.0" },
    { name = "python-dotenv", specifier = ">=1.0.0" },
]

[[package]]
name = "zipp"
version = "3.21.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/3f/50/bad581df71744867e9468ebd0bcd6505de3b275e06f202c2cb016e3ff56f/zipp-3.21.0.tar.gz", hash = "sha256:2c9958f6430a2040341a52eb608ed6dd93ef4392e02ffe219417c1b28b5dd1f4", size = 24545 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b7/1a/7e4798e9339adc931158c9d69ecc34f5e6791489d469f5e50ec15e35f458/zipp-3.21.0-py3-none-any.whl", hash = "sha256:ac1bbe05fd2991f160ebce24ffbac5f6d11d83dc90891255885223d42b3cd931", size = 9630 },
]

================
File: .github/dependabot.yml
================
version: 2
updates:
  - package-ecosystem: "pip"
    directory: "/"
    schedule:
      interval: "weekly"

================
File: docs/capabilities.json
================
{
  "capabilities": {
    "experimental": {},
    "logging": null,
    "prompts": {
      "listChanged": false
    },
    "resources": {
      "subscribe": false,
      "listChanged": false
    },
    "tools": {
      "listChanged": false
    }
  },
  "tools": [
    {
      "name": "claim_device",
      "description": "",
      "inputSchema": {
        "$defs": {
          "ClaimDeviceRequest": {
            "description": "Request model for claiming a device.",
            "properties": {
              "name": {
                "description": "Friendly name for the device",
                "title": "Name",
                "type": "string"
              },
              "space_id": {
                "description": "Identifier of the space to assign the device",
                "title": "Space Id",
                "type": "integer"
              },
              "mac": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "Device MAC address (optional)",
                "title": "Mac"
              },
              "sn": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "Device serial number (optional)",
                "title": "Sn"
              },
              "cloud_id": {
                "default": "",
                "description": "Cloud identifier for the device (optional)",
                "title": "Cloud Id",
                "type": "string"
              }
            },
            "required": [
              "name",
              "space_id"
            ],
            "title": "ClaimDeviceRequest",
            "type": "object"
          }
        },
        "properties": {
          "request": {
            "$ref": "#/$defs/ClaimDeviceRequest"
          }
        },
        "required": [
          "request"
        ],
        "title": "claim_deviceArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "delete_device",
      "description": "",
      "inputSchema": {
        "$defs": {
          "DeviceId": {
            "description": "Model identifying a device.",
            "properties": {
              "device_id": {
                "description": "Unique device identifier",
                "title": "Device Id",
                "type": "string"
              }
            },
            "required": [
              "device_id"
            ],
            "title": "DeviceId",
            "type": "object"
          }
        },
        "properties": {
          "data": {
            "$ref": "#/$defs/DeviceId"
          }
        },
        "required": [
          "data"
        ],
        "title": "delete_deviceArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "update_device",
      "description": "",
      "inputSchema": {
        "$defs": {
          "UpdateDeviceArgs": {
            "description": "Parameters for updating a device.",
            "properties": {
              "device_id": {
                "description": "Unique device identifier",
                "title": "Device Id",
                "type": "string"
              },
              "configuration": {
                "additionalProperties": true,
                "description": "Configuration parameters",
                "title": "Configuration",
                "type": "object"
              }
            },
            "required": [
              "device_id",
              "configuration"
            ],
            "title": "UpdateDeviceArgs",
            "type": "object"
          }
        },
        "properties": {
          "data": {
            "$ref": "#/$defs/UpdateDeviceArgs"
          }
        },
        "required": [
          "data"
        ],
        "title": "update_deviceArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "send_command",
      "description": "",
      "inputSchema": {
        "$defs": {
          "SendCommandRequest": {
            "description": "Parameters for sending a command.",
            "properties": {
              "name": {
                "description": "Command name",
                "title": "Name",
                "type": "string"
              },
              "friendly_name": {
                "description": "Human-friendly command name",
                "title": "Friendly Name",
                "type": "string"
              },
              "file_id": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "File identifier if the command includes a file",
                "title": "File Id"
              },
              "extra_params": {
                "additionalProperties": true,
                "description": "Additional parameters",
                "title": "Extra Params",
                "type": "object"
              },
              "device_id": {
                "description": "Unique device identifier",
                "title": "Device Id",
                "type": "string"
              }
            },
            "required": [
              "name",
              "friendly_name",
              "device_id"
            ],
            "title": "SendCommandRequest",
            "type": "object"
          }
        },
        "properties": {
          "data": {
            "$ref": "#/$defs/SendCommandRequest"
          }
        },
        "required": [
          "data"
        ],
        "title": "send_commandArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "cancel_command",
      "description": "",
      "inputSchema": {
        "$defs": {
          "CancelCommandRequest": {
            "description": "Parameters for canceling a command.",
            "properties": {
              "name": {
                "description": "Command name",
                "title": "Name",
                "type": "string"
              },
              "friendly_name": {
                "description": "Human-friendly command name",
                "title": "Friendly Name",
                "type": "string"
              },
              "file_id": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "File identifier if the command includes a file",
                "title": "File Id"
              },
              "extra_params": {
                "additionalProperties": true,
                "description": "Additional parameters",
                "title": "Extra Params",
                "type": "object"
              },
              "device_id": {
                "description": "Unique device identifier",
                "title": "Device Id",
                "type": "string"
              },
              "command_id": {
                "description": "Unique command identifier",
                "title": "Command Id",
                "type": "string"
              }
            },
            "required": [
              "name",
              "friendly_name",
              "device_id",
              "command_id"
            ],
            "title": "CancelCommandRequest",
            "type": "object"
          }
        },
        "properties": {
          "data": {
            "$ref": "#/$defs/CancelCommandRequest"
          }
        },
        "required": [
          "data"
        ],
        "title": "cancel_commandArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "update_ticket",
      "description": "",
      "inputSchema": {
        "$defs": {
          "UpdateTicketRequest": {
            "properties": {
              "ticket_id": {
                "description": "Unique ticket identifier",
                "title": "Ticket Id",
                "type": "string"
              },
              "title": {
                "description": "New title for the ticket",
                "title": "Title",
                "type": "string"
              },
              "description": {
                "description": "New description",
                "title": "Description",
                "type": "string"
              }
            },
            "required": [
              "ticket_id",
              "title",
              "description"
            ],
            "title": "UpdateTicketRequest",
            "type": "object"
          }
        },
        "properties": {
          "data": {
            "$ref": "#/$defs/UpdateTicketRequest"
          }
        },
        "required": [
          "data"
        ],
        "title": "update_ticketArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "mark_ticket_resolved",
      "description": "",
      "inputSchema": {
        "$defs": {
          "MarkTicketResolvedRequest": {
            "properties": {
              "ticket_id": {
                "description": "Unique ticket identifier",
                "title": "Ticket Id",
                "type": "string"
              }
            },
            "required": [
              "ticket_id"
            ],
            "title": "MarkTicketResolvedRequest",
            "type": "object"
          }
        },
        "properties": {
          "data": {
            "$ref": "#/$defs/MarkTicketResolvedRequest"
          }
        },
        "required": [
          "data"
        ],
        "title": "mark_ticket_resolvedArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "send_ticket_message",
      "description": "",
      "inputSchema": {
        "$defs": {
          "SendTicketMessageRequest": {
            "properties": {
              "ticket_id": {
                "description": "Unique ticket identifier",
                "title": "Ticket Id",
                "type": "string"
              },
              "message": {
                "description": "Message content to send",
                "title": "Message",
                "type": "string"
              }
            },
            "required": [
              "ticket_id",
              "message"
            ],
            "title": "SendTicketMessageRequest",
            "type": "object"
          }
        },
        "properties": {
          "data": {
            "$ref": "#/$defs/SendTicketMessageRequest"
          }
        },
        "required": [
          "data"
        ],
        "title": "send_ticket_messageArguments",
        "type": "object"
      },
      "annotations": null
    },
    {
      "name": "search_device_histories",
      "description": "",
      "inputSchema": {
        "$defs": {
          "SearchDeviceHistoriesRequest": {
            "properties": {
              "status": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "Filter by status",
                "title": "Status"
              },
              "from_date": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "Start ISO time",
                "title": "From Date"
              },
              "to_date": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "End ISO time",
                "title": "To Date"
              },
              "device_id": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "Filter by device",
                "title": "Device Id"
              },
              "space_id": {
                "anyOf": [
                  {
                    "type": "integer"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "Filter by space",
                "title": "Space Id"
              },
              "name": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "null"
                  }
                ],
                "default": null,
                "description": "Filter by name",
                "title": "Name"
              }
            },
            "title": "SearchDeviceHistoriesRequest",
            "type": "object"
          }
        },
        "properties": {
          "params": {
            "$ref": "#/$defs/SearchDeviceHistoriesRequest"
          }
        },
        "required": [
          "params"
        ],
        "title": "search_device_historiesArguments",
        "type": "object"
      },
      "annotations": null
    }
  ],
  "resources": [
    {
      "uri": "devices://",
      "name": "list_devices",
      "description": "",
      "mimeType": "text/plain",
      "size": null,
      "annotations": null
    },
    {
      "uri": "incidents://",
      "name": "list_incidents",
      "description": "",
      "mimeType": "text/plain",
      "size": null,
      "annotations": null
    },
    {
      "uri": "tickets://",
      "name": "list_tickets",
      "description": "",
      "mimeType": "text/plain",
      "size": null,
      "annotations": null
    }
  ],
  "prompts": []
}

================
File: examples/basic_usage.py
================
"""Example usage of the Xyte MCP server using mcp-client."""

import asyncio
from mcp.client.stdio import stdio_client, StdioServerParameters


async def main() -> None:
    params = StdioServerParameters(command=["serve"])
    async with stdio_client(params) as client:
        result = await client.call_tool("list_devices")
        print("Devices:", result)
        if result.get("devices"):
            dev_id = result["devices"][0]["id"]
            status = await client.call_resource(f"device://{dev_id}/status")
            print("Status:", status)


if __name__ == "__main__":
    asyncio.run(main())

================
File: scripts/generate_capabilities.py
================
from pathlib import Path
import sys
sys.path.append(str(Path(__file__).resolve().parents[1] / "src"))
import asyncio
import json
from mcp.server.lowlevel.server import NotificationOptions

from xyte_mcp_alpha.server import get_server


async def main() -> None:
    server = get_server()
    tools = [t.model_dump(mode="json") for t in await server.list_tools()]
    resources = [r.model_dump(mode="json") for r in await server.list_resources()]
    prompts = [p.model_dump(mode="json") for p in await server.list_prompts()]

    mcp_server = server._mcp_server
    capabilities = mcp_server.get_capabilities(NotificationOptions(), {})

    spec = {
        "capabilities": capabilities.model_dump(mode="json"),
        "tools": tools,
        "resources": resources,
        "prompts": prompts,
    }

    out_file = Path("docs/capabilities.json")
    out_file.write_text(json.dumps(spec, indent=2))
    print(f"Wrote {out_file}")


if __name__ == "__main__":
    asyncio.run(main())

================
File: scripts/generate_wrappers_md.py
================
from pathlib import Path
import sys
import asyncio
sys.path.append(str(Path(__file__).resolve().parents[1] / "src"))

from xyte_mcp_alpha.server import get_server


def extract_fields(schema: dict) -> str:
    if not schema:
        return ""
    props = schema.get("properties", {})
    if not props:
        return ""
    first = next(iter(props.values()))
    if "$ref" in first:
        ref = first["$ref"].split("/")[-1]
        defs = schema.get("$defs", {}) or schema.get("definitions", {})
        subprops = defs.get(ref, {}).get("properties", {})
    else:
        subprops = props
    return ", ".join(subprops.keys())


async def main() -> None:
    server = get_server()
    tools = await server.list_tools()
    resources = await server.list_resources()
    templates = await server.list_resource_templates()

    lines = ["# XYTE API Wrappers", "", "## Tools", "", "| Name | Parameters |", "| ---- | ---------- |"]
    for t in tools:
        params = extract_fields(t.inputSchema)
        lines.append(f"| `{t.name}` | {params} |")

    lines.extend(["", "## Resources", "", "| URI | Name |", "| --- | ---- |"])
    for r in resources:
        lines.append(f"| `{r.uri}` | {r.name} |")
    for tmpl in templates:
        lines.append(f"| `{tmpl.uriTemplate}` | {tmpl.name or ''} |")

    Path("docs/wrappers.md").write_text("\n".join(lines))
    print("Generated docs/wrappers.md")


if __name__ == "__main__":
    asyncio.run(main())

================
File: scripts/profile_server.py
================
#!/usr/bin/env python
"""Basic profiling helper for the MCP server."""

import cProfile
import pstats
import asyncio

from xyte_mcp_alpha import get_server
from mcp.server.stdio import stdio_server


async def _run_for(duration: float) -> None:
    """Run the stdio server for a limited duration."""
    async with asyncio.timeout(duration):
        await stdio_server(get_server())


def main() -> None:
    profiler = cProfile.Profile()
    profiler.enable()
    try:
        asyncio.run(_run_for(5))
    finally:
        profiler.disable()
        pstats.Stats(profiler).sort_stats("cumtime").print_stats(20)


if __name__ == "__main__":
    main()

================
File: src/xyte_mcp_alpha/__main__.py
================
"""Main entry point for xyte-mcp-alpha."""


def main():
    """Main function."""
    print("Hello from xyte-mcp-alpha!")


if __name__ == "__main__":
    main()

================
File: src/xyte_mcp_alpha/tasks.py
================
from __future__ import annotations

import asyncio
from uuid import uuid4
from typing import Dict, Any

from mcp.server.fastmcp import Context

from .deps import get_client
from .utils import handle_api
from .models import SendCommandRequest


class TaskInfo:
    def __init__(self) -> None:
        self.status: str = "pending"
        self.result: Dict[str, Any] | None = None
        self.error: str | None = None


TASKS: Dict[str, TaskInfo] = {}


async def send_command_async(data: SendCommandRequest, ctx: Context) -> Dict[str, Any]:
    """Initiate a command asynchronously and return a task ID."""

    task_id = str(uuid4())
    info = TaskInfo()
    TASKS[task_id] = info

    async def _runner() -> None:
        try:
            await ctx.report_progress(0, 100)
            async with get_client() as client:
                result = await handle_api("send_command", client.send_command(data.device_id, data))
            info.result = result
            info.status = "done"
            await ctx.report_progress(100, 100)
        except Exception as e:  # pragma: no cover - background
            info.status = "error"
            info.error = str(e)

    asyncio.create_task(_runner())
    return {"task_id": task_id}


async def get_task_status(task_id: str) -> Dict[str, Any]:
    """Return status information about a previously started task."""
    info = TASKS.get(task_id)
    if not info:
        return {"status": "unknown"}
    return {"status": info.status, "result": info.result, "error": info.error}

================
File: src/xyte_mcp_alpha/user.py
================
from __future__ import annotations

from pydantic import BaseModel, Field
from typing import Dict

class UserPreferences(BaseModel):
    """Simple user preferences model."""

    preferred_devices: list[str] = Field(default_factory=list)
    default_room: str | None = None

# Example in-memory store mapping user tokens to preferences
USER_PREFERENCES: Dict[str, UserPreferences] = {
    "demo-token": UserPreferences(preferred_devices=["device1"], default_room="101"),
}


def get_preferences(user_token: str) -> UserPreferences:
    """Return preferences for the given user token or empty preferences."""
    return USER_PREFERENCES.get(user_token, UserPreferences())

================
File: tests/test_discovery_and_events.py
================
import asyncio
import unittest
from starlette.testclient import TestClient

from xyte_mcp_alpha.http import app
from xyte_mcp_alpha import events


class DiscoveryEventTestCase(unittest.TestCase):
    def setUp(self):
        import os
        os.environ.setdefault("XYTE_API_KEY", "test")
        self.client = TestClient(app)
        # Clear event queue
        while not events._event_queue.empty():
            events._event_queue.get_nowait()

    def test_tool_and_resource_listing(self):
        resp = self.client.get('/tools')
        self.assertEqual(resp.status_code, 200)
        tools = resp.json()
        self.assertTrue(any(t['name'] == 'claim_device' for t in tools))

        resp = self.client.get('/resources')
        self.assertEqual(resp.status_code, 200)
        resources_list = resp.json()
        self.assertTrue(any(r['uri'] == 'devices://' for r in resources_list))

    def test_event_flow(self):
        payload = {"type": "device_offline", "data": {"id": "abc"}}
        resp = self.client.post('/webhook', json=payload)
        self.assertEqual(resp.status_code, 200)

        async def wait_event():
            return await asyncio.wait_for(
                events.get_next_event(events.GetNextEventRequest(event_type="device_offline")),
                1,
            )

        event = asyncio.run(wait_event())
        self.assertEqual(event['data']['id'], 'abc')


if __name__ == '__main__':
    unittest.main()

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
PIPFILE.lock

# Virtual Environment
venv/
env/
ENV/
virtual_env/
.venv/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/
.nox/
.hypothesis/

# Jupyter
.ipynb_checkpoints

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Logs
*.log

================
File: AGENTS.md
================
Based on the codebase, Iâ€™ll generate a detailed `AGENTS.md` file that serves as a practical reference for agents interacting with the MCP server. It will include authentication, session handling, tool usage, error reporting, and context management, based on actual server behavior.

I'll let you know once it's ready.


# Xyte MCP Server â€“ Agent Integration Guide

This guide explains how agents (human or AI) can interact with the Xyte MCP server to control devices, manage tickets, and handle events. It covers authentication, using tools and resources, maintaining context, error codes, event consumption, asynchronous commands, and built-in workflow prompts. The goal is to provide clear, actionable guidance based on the serverâ€™s implementation.

## Authentication

Before using any MCP capabilities, the agent (or the environment hosting the agent) must authenticate with Xyteâ€™s API via the MCP serverâ€™s configuration:

* **API Key:** Set the environment variable `XYTE_API_KEY` to your organizationâ€™s API key. This is required for all operations. The server uses this key to authorize requests to Xyteâ€™s cloud API.
* **User Token (Optional):** If you want the server to act on behalf of a specific user (for user-scoped data), provide a `XYTE_USER_TOKEN`. If this token is set, it will override the API key for relevant calls. In other words, the MCP server will use the user token instead of the org API key when making API requests if the token is available. (You can also pass a user token at runtime for specific calls as needed.)
* **Base URL & Other Config:** By default, the server targets Xyteâ€™s production API base URL. You can override `XYTE_BASE_URL` for testing, though typically not needed. Other optional settings include `XYTE_CACHE_TTL` (caching duration for certain lookups), `XYTE_RATE_LIMIT` (to tune the rate limit threshold), and `XYTE_ENV` (environment name). See the provided `.env.example` for reference.

**Usage:** Typically, you will provide these credentials via a `.env` file or environment variables before launching the MCP server. The server reads them on startup. Once configured, agents do not need to send authentication headers on each request â€“ the server handles auth with Xyte internally using the provided key/token.

Ensure that the API key and token remain secure. They grant control over your organizationâ€™s devices and data. If using a user token, restrict its scope appropriately (e.g. read-only vs. full control depending on use case).

## Tool Invocation

The MCP server exposes a variety of **tools** â€“ discrete actions the agent can invoke to perform operations (sending commands, updating records, etc.). Each tool has a name and expects certain inputs. Agents call these tools by name, supplying the required parameters, and receive a structured result or confirmation.

**Available Tools:** Key tools and their inputs include:

* **`claim_device`** (`name`, `space_id`, *`mac`*, *`sn`*, *`cloud_id`*): Claim (register) a new device into the organization with a friendly name and target space. Optional fields like MAC address, serial number, or cloud ID can be provided if needed.
* **`delete_device`** (`device_id`): Remove a device from the organization by its ID. This is a destructive action â€“ once deleted, the device is unassigned from the org.
* **`update_device`** (`device_id`, `configuration`): Update a deviceâ€™s configuration. Supply the device ID and a dictionary of configuration parameters to apply (e.g. settings or attributes the device should adopt).
* **`send_command`** (`device_id`, `name`, `friendly_name`, *`file_id`*, *`extra_params`*): Send a control command to a device. You must specify the device ID, the commandâ€™s technical name, and a human-friendly name (for logging or UI). Optionally include a file ID (if the command involves transferring a file) and any extra parameters required by the command. This tool will execute the command on the device via Xyteâ€™s API.
* **`cancel_command`** (`device_id`, `command_id`, `name`, `friendly_name`, *`file_id`*, *`extra_params`*): Cancel a previously sent command. Provide the target device ID and the specific commandâ€™s ID to cancel, along with the same command name/details that were used to send it. (Using the same `name` and `friendly_name` helps identify the command to cancel.) This will attempt to halt the commandâ€™s execution on the device.
* **`update_ticket`** (`ticket_id`, `title`, `description`): Modify the details of a support ticket (e.g. update its title or description).
* **`mark_ticket_resolved`** (`ticket_id`): Mark a support ticket as resolved/closed.
* **`send_ticket_message`** (`ticket_id`, `message`): Post a new message to the conversation thread of a support ticket (e.g. an agentâ€™s response or a user follow-up).
* **`search_device_histories`** (*filters:* `status`, `from_date`, `to_date`, *`device_id`*, *`space_id`*, *`name`*): Search a deviceâ€™s history records (logs of events/commands) with optional filtering criteria. You can filter by status type, a date range (ISO timestamps), a specific device or space, or by name of the event. This returns matching history entries (e.g. errors, reboots, status changes) for troubleshooting or analysis.
* **`get_device_analytics_report`** (`device_id`, *`period`*): Retrieve usage analytics for a given device over a time period. By default, it fetches data for the last 30 days, but you can specify a period like `"last_7_days"` or other supported ranges. This can return metrics such as uptime, usage hours, etc., depending on what the Xyte API provides.
* **`set_context`** (`device_id`, `space_id`): Set session defaults (context) for the agentâ€™s subsequent calls. By providing a device ID and/or space ID, you inform the server that future tool calls can assume these values by default if not explicitly given. This is essentially a way to avoid repeating common parameters. *(More on context in the **Context Management** section.)*

Additionally, there are specialized tools for asynchronous command execution and event retrieval (`send_command_async`, `get_task_status`, `get_next_event`), which are covered in later sections.

### Invoking Tools and Dry-Run Considerations

To invoke a tool, the agent typically issues a request or calls a function by the toolâ€™s name with the required parameters. For example, using a Python-like pseudo-code:

```python
# Example: Send a reboot command to a device
result = send_command({
    "device_id": "device123",
    "name": "reboot",
    "friendly_name": "Reboot Device"
})
```

In this call, the MCP server will execute the **send\_command** tool with the provided JSON payload. Under the hood it will call the Xyte API to send the command, then return a result back to the agent.

**Dry-Run / Read-Only vs. Destructive Tools:** Some tools are safe to call without side effects (read-only), while others change state or trigger actions (destructive):

* Tools like `search_device_histories` and `get_device_analytics_report` only retrieve data; they do not alter anything. The server marks these as read-only tools. Agents can invoke them freely to gather information (akin to a *dry-run* since they are purely queries).
* Tools that create, modify, or delete things (e.g. `claim_device`, `delete_device`, `update_device`, `send_command`) are **destructive** (they change the real system state). Agents should use caution with these: ensure the context and parameters are correct and perhaps confirm with the user (if applicable) before executing. There is no built-in simulation mode for these actions â€“ calling them will perform the action. If an agent is uncertain, it can first use resources or read-only tools (like checking `devices://` or device status) to verify conditions before invoking a destructive tool.

### Tool Responses and Results

Most tools return either a raw data object (usually reflecting the API response) or a structured **ToolResponse** with additional metadata:

* **Raw Data:** For many tools, especially those that retrieve information or perform simple updates, the result will be a dictionary of data. For example, `list_devices` (via `devices://`) returns a list of devices, `get_ticket` returns the ticket details, `update_device` returns the updated device record, etc. The data keys and format mirror the Xyte API. The agent can directly use this data for reasoning or UI. For instance, `delete_device` might return a confirmation object or an empty result indicating success.

* **`ToolResponse` Object:** Some tools provide a richer response with a summary and guidance for next steps. The `ToolResponse` model includes:

    * `data`: the primary data payload (e.g. the API response or relevant result),
    * `summary`: a short human-readable summary of what happened,
    * `next_steps`: a list of suggested next action identifiers (tool names or resource names),
    * `related_tools`: a list of other tool names that might be relevant.

  For example, the **send\_command** tool returns a `ToolResponse` that includes a summary message and a suggested next step. If you send a reboot command, the response might look like:

  ```json
  {
    "data": { /* command issuance result from Xyte */ },
    "summary": "Command 'Reboot Device' sent to device device123",
    "next_steps": ["get_device_status"]
  }
  ```

  Here, `summary` confirms the action, and `next_steps` suggests that the agent should next check the device status (using the `device://device123/status` resource, which corresponds to â€œget\_device\_statusâ€). The agent can use this info to decide its next move automatically. Another example is **set\_context**, which returns a ToolResponse with a summary `"Context updated"` and the updated context state as data.

* **Interpreting the Response:** Agents should inspect the `summary` and `next_steps` when present. The summary can be conveyed to end-users or used in reasoning to confirm the actionâ€™s outcome. The `next_steps` list (if provided) are recommendations from the server on what to do next â€“ for example, after sending a command, checking status or history is often prudent. Agents can treat these as hints to form their subsequent tool calls. The `related_tools` field (currently not widely used) may list other tools relevant to the situation; an agent can consider those as alternate approaches or additional actions.

In cases where a tool returns only raw data (no summary), it means the actionâ€™s outcome is straightforward (e.g., a data fetch or a direct update). The agent should examine the data or check for expected fields (like a success flag or updated values) to determine success. When errors occur, tools will not return a normal response â€“ instead, an error (exception) is raised, as described in **Error Handling** below.

Finally, agents can discover the available tools and their descriptions programmatically if needed. The MCP server provides a `GET /tools` endpoint that lists all tool names, descriptions, and hints about their safety (read-only or destructive). This can be useful for an agent that wants to self-inspect capabilities.

## Resources

**Resources** are read-only data endpoints exposed by the MCP server. They allow agents to query the current state of devices, tickets, incidents, etc., using a simple URI format. Resources do not require any input besides the identifier in the URI (if any), and they return structured data from the Xyte system.

Available resource URIs include:

* **`devices://`** â€“ Retrieves **all devices** in the organization. Returns a list of device objects (each containing details like device `id`, name, type, status, assigned space, etc.). For example, an agent can use this to get the list of devices and then filter or select one for further actions.
* **`device://{device_id}/status`** â€“ Fetches the **current status and details of a specific device**. Replace `{device_id}` with the target deviceâ€™s ID. The result includes information such as power state, online/offline status, current settings, and other telemetry available for that device.
* **`device://{device_id}/commands`** â€“ Lists all **commands issued to the device**, typically including recent and pending commands. This can show command history or currently running commands for that device (with details like command IDs, names, timestamps, statuses).
* **`device://{device_id}/histories`** â€“ Returns the **history records for a device**, which are logs of events and actions related to that device. This may include status changes, error reports, command results, etc. Agents can scan this to verify if a certain action happened (e.g., whether a reboot took place, or if any errors were reported recently).
* **`organization://info/{device_id}`** â€“ Retrieves **organization-specific info for a given device**. This might include context like what organization or subscription the device is under, or any metadata linking the device to organizational structure. (This is a somewhat special case: the underlying API expects a device ID to return info about the org/project that device belongs to.)
* **`incidents://`** â€“ Lists all **current incidents** in the organization. Incidents are typically ongoing issues or alerts (e.g., device failures, offline alerts, etc.). The data returned would include incident IDs, affected device or room, description, severity, status, etc.
* **`tickets://`** â€“ Lists all **support tickets** in the organization (open and maybe recent closed ones depending on API). Each ticket includes details like ticket ID, title, description, status, associated device or user, etc. Agents might use this to find relevant support issues.
* **`ticket://{ticket_id}`** â€“ Fetches a **specific support ticket** by ID, including its full details and conversation messages. Use this to get the latest state of a ticket (e.g., to see if a user replied or to gather context when handling a ticket).
* **`user://{user_token}/preferences`** â€“ Retrieves the **stored preferences for a given user** (identified by their user token). Preferences could include things like the userâ€™s preferred devices or default room. For example, the server might store that a particular user cares about devices X, Y, Z. The returned data (e.g., a `preferred_devices` list) can inform which devices to focus on for that user.
* **`user://{user_token}/devices`** â€“ Lists **devices filtered by a userâ€™s preferences**. In effect, this returns a subset of `devices://` â€“ those devices that the specified user is most interested in (their â€œpreferred devicesâ€). The server implements this by taking all devices and cross-referencing with the `preferred_devices` list from that userâ€™s preferences. Agents can use this to personalize operations, focusing on the userâ€™s own equipment.

**Using Resources:** In practice, an agent can fetch a resource by referencing its URI in a query or via the MCP protocol. For example, an agent might simply request `devices://` to get the device list. If using the HTTP API, the MCP server provides a `GET /resources` endpoint that lists all resource URIs available. However, to retrieve the actual data of a resource, the agent will typically call the resource through the MCP session (for instance, by including the URI in the agentâ€™s message or via a dedicated call in code). The exact mechanism depends on the integration (some agent frameworks allow the agent to â€œopenâ€ a resource URI directly).

Regardless of how theyâ€™re fetched, resources always return **structured JSON data** representing the current state from Xyteâ€™s perspective. Here are a few examples of what data to expect:

* `devices://` returns an object containing all devices, likely under a key like `"devices"` (e.g., `{"devices": [ {id: ..., name: ..., status: ...}, {...} ]}`). An agent can iterate through this list to find a device of interest.
* `device://123/status` might return `{ "device": { "id": "123", "name": "Projector A", "online": true, "last_seen": "...", ... } }`. Itâ€™s essentially the same data youâ€™d get from Xyteâ€™s â€œget deviceâ€ API.
* `device://123/histories` could return a list of history entries: `{ "histories": [ {...}, {...} ] }` or a similar structure, where each entry might include a timestamp, event type, and message (e.g., â€œTemperature highâ€ or â€œRebootedâ€).
* `incidents://` might look like `{ "incidents": [ { "id": "inc1", "device_id": "123", "description": "Device offline", "status": "open", ...}, {...} ] }`.
* `user://demo-token/preferences` might return `{ "preferred_devices": ["device1"], "default_room": "101" }` as per the example in the code.

Agents should use these resources to **gather context and make informed decisions**. For instance, before sending a reboot command, an agent could check `device://{id}/status` and `device://{id}/histories` to see if the device is actually unresponsive and if it has a history of reboots or errors. Or, when a user asks about ongoing issues, the agent could consult `incidents://` and `tickets://` to provide an accurate update.

Remember, resources are **read-only and safe** â€“ using them does not change anything on the system. They are efficient for an agent to call as needed (some data may even be cached by the server for performance). The serverâ€™s internal rate limiting applies across all calls, so high-frequency polling of resources should be done judiciously (but occasional use is fine).

## Context Management

The MCP server supports session-level context so that agents can avoid repeating common parameters. By using the **`set_context`** tool, an agent can store defaults like the current device ID or space (room) ID for the ongoing session. Subsequent tool calls will automatically use these context values if their parameters are not explicitly provided.

**Setting Context:** Call the `set_context` tool with a `device_id` and/or `space_id`. For example:

```python
# Set the session context to focus on device "device123" and space 42
set_context({"device_id": "device123", "space_id": 42})
```

This will store `"current_device_id": "device123"` and `"current_space_id": 42` in the sessionâ€™s state. The tool returns a confirmation (a ToolResponse containing the updated context state and a summary "Context updated"). Only the fields you provide are updated, so you can set one without the other.

**Using Context in Tools:** Once context is set, you can omit those parameters in future tool calls. The server will automatically fill them in from the context:

* If you call `send_command` without specifying a `device_id`, the server will default to the `current_device_id` in the context (if one is set). For instance, after setting context as above, you could just do `send_command({"name": "reboot", "friendly_name": "Reboot Device"})` without explicitly providing `"device_id": "device123"`. The server will infer it from context and send the command to *device123*. This makes command sequences more convenient, especially when an agent is focused on one device at a time.
* Similarly, other tools that require a device or space ID may look to context. For example, `update_device`, `delete_device`, or `search_device_histories` could use the contextâ€™s `current_device_id` if you donâ€™t provide one in the call. (If both context and parameters are provided, the explicit parameter would typically take precedence.) **Important:** Not every tool currently auto-applies context, but those that logically operate on a device will check for a default. If a required identifier is missing in both the call and context, youâ€™ll get an error (e.g., "device\_id is required").
* The `current_space_id` can be used in a similar way for tools or resources that operate at the space level (for example, if a future tool lists devices in the current space, it could use this). In the present set of tools, space\_id might be used as a filter in `search_device_histories` or for potential future expansions.

**Persistent Session State:** The context is tied to the agentâ€™s session (the `Context` object in the MCP server) â€“ it is not a global setting and not stored across server restarts. If the session ends or the agent disconnects, the context goes away. Agents should set context at the beginning of a session or when a new focus is needed. For example, if a user switches context (â€œNow letâ€™s look at a different deviceâ€¦â€), the agent should update the context via `set_context` with the new device\_id.

**Context Required:** Note that `set_context` itself requires a session context to operate; you cannot call it outside of an agent session. If, for some reason, the context object is missing, the tool will raise an error "Context required" (this typically means itâ€™s being invoked in an improper way â€“ in normal agent use this shouldnâ€™t happen).

**Additional Context Info:** The server may store other helpful tidbits in the session state. For instance, when you send a command, the server records the command name as `last_command` in the context state. An agent could use this (if exposed) to recall what it last did. This isnâ€™t usually needed explicitly, but itâ€™s part of the design to help track the conversation state. The main fields youâ€™ll set and rely on are `current_device_id` (and possibly `current_space_id`).

**Example Workflow:** Suppose a user says â€œReboot the projector in Room 101.â€ The agent might:

1. Find the device ID of the projector in Room 101 (perhaps by searching `devices://` by name or space).
2. Call `set_context` with that `device_id` (and maybe the `space_id` for Room 101).
3. Call `send_command` with `name="reboot"` (no need to include device\_id because context provides it).
4. After command execution, call `device://{device_id}/status` or check `device://{device_id}/histories` to verify the reboot, as suggested by the toolâ€™s `next_steps`.

Using context makes step 3 simpler and less error-prone, because you donâ€™t have to carry the device ID through every call manually â€“ the server remembers it for you.

## Error Handling

When a tool or resource call cannot be completed, the MCP server will raise an **MCPError** with a specific `code` and a descriptive `message`. Agents should be prepared to handle these errors. The error `code` is especially important, as it indicates the type of failure and thus how the agent might respond or recover. Here are common error codes and recommended strategies:

* **`missing_device_id` / `missing_context`:** These errors indicate that a required identifier was not provided. For example, an agent tried to call `send_command` without a device\_id and none was set in context, or called `set_context` without any context available. In this case, the agent should supply the missing information â€“ e.g., ensure `device_id` is included or call `set_context` first. Essentially, itâ€™s a prompt that the agent needs to specify something it left out.
* **`invalid_params` / `invalid_device_id` / `invalid_ticket_id`:** The input provided was of the wrong format or invalid. This could happen if an ID is malformed or empty, or a required field in a payload is missing/incorrect. The agent should double-check the values itâ€™s sending. For instance, make sure device IDs and ticket IDs are strings (not numbers or null), and that required fields like ticket title/description are present. This is generally a bug in the agentâ€™s logic or an unexpected input from the user â€“ it should be corrected and the tool retried.
* **`device_not_found` / `ticket_not_found`:** The specified resource does not exist. The server tried to fetch or act on a device/ticket by ID and the Xyte API returned a 404 Not Found. The agent should interpret this as: â€œthe given ID is wrong or the item has been removed.â€ Recovery might involve informing the user that the device or ticket wasnâ€™t found, or suggesting to list available devices/tickets to pick a correct ID. If this occurred during an operation (say updating a ticket), it might mean the ticket was closed or deleted by someone else.
* **`rate_limited`:** Too many requests have been sent in a short time. The MCP server enforces a rate limit (e.g., 60 calls per minute by default) to avoid overloading the Xyte API. If an agent hits this limit, it will receive a `rate_limited` error. The agent should pause further actions for a brief period to let the window reset. A strategy could be to wait (e.g., for 1 minute) before retrying, and avoid making rapid repetitive calls. If the agent was in a loop, it should break out or slow down. This error exists to protect both the system and the agentâ€™s integration from being throttled by the upstream API.
* **`timeout` / `network_error` / `service_unavailable`:** These codes indicate temporary connectivity or server issues. A `timeout` means the request to Xyte took too long and was aborted; `network_error` means there was a low-level network failure reaching the API (e.g., DNS failure or connection drop); `service_unavailable` corresponds to a 503 error, implying Xyteâ€™s service is down or overloaded. In all these cases, the agent should assume the operation didnâ€™t complete and **retry later**. The agent can inform the user of a temporary issue (â€œThe server is not responding right now, I will try again shortly.â€) and then try the same call after a delay. These errors are generally not caused by the agentâ€™s logic but by external conditions. Usually, simply waiting and retrying is the best course (possibly with a limited number of attempts before giving up and logging an error).
* **`validation_error`:** This is related to `invalid_params` â€“ it specifically means the data format failed validation (e.g., JSON schema didnâ€™t match). The message may include details about what was expected. The agent should correct the format of the request payload.
* **`unknown_error`:** A catch-all for any unexpected exception. This means something happened that the server didnâ€™t anticipate (could be a bug, an unhandled API response, etc.). The agent should not retry immediately, as the same unknown condition might persist. Instead, it may log the error, possibly notify a human operator or fallback to a safe default. From the userâ€™s perspective, the agent can apologize and say it cannot complete the request due to an internal error. Since the cause is unclear, automated recovery is hard â€“ often the best an agent can do is provide context (e.g., include the error message) for debugging.

When an MCPError is raised, the serverâ€™s HTTP response (if youâ€™re using HTTP) will likely be a 4xx status with a JSON body containing the `code` and `message`. If youâ€™re using an SDK or the agent is integrated in-process, it might surface as an exception object with those attributes. In either case, use the `code` to drive logic (as outlined above) and the `message` for logging or user-facing info if needed.

**Example:** If an agent tries to send a command without setting a device, it gets `{"code": "missing_device_id", "message": "device_id is required"}`. The agent should realize it forgot to specify which device, perhaps ask the user or infer the device from context, set it, and try again. If it gets `device_not_found`, it might say to the user â€œI couldnâ€™t find that device â€“ please check the ID or name.â€ If `rate_limited`, the agent could wait 60 seconds before continuing its sequence of actions.

By handling these errors gracefully, the agent will be more robust and user-friendly, rather than simply failing or getting stuck.

## Event Handling

The MCP server can queue external **events** (similar to webhook notifications) and provide them to agents on demand. This allows agents to react to asynchronous occurrences, such as device status changes or new tickets, in a controlled way.

Events are produced outside the agentâ€™s direct requests â€“ for example, Xyteâ€™s cloud might send a webhook to the MCP server when a device goes offline. The server enqueues these events, and the agent can consume them using the **`get_next_event`** tool.

**Event Model:** Each event has a `type` (a short string describing what kind of event it is) and a `data` payload (a dictionary with details about the event). The serverâ€™s internal event model looks like:

```json
{
  "type": "<event_type>",
  "data": { ... }
}
```

For instance, an event could be: `{"type": "device_offline", "data": { "id": "device123", "timestamp": "...", ... }}` meaning device with ID "device123" went offline at a certain time.

**Producing Events:** The MCP server exposes a webhook endpoint (typically `/webhook`) where such event payloads can be posted. In a deployed scenario, youâ€™d configure Xyte or other systems to send events (like device alerts) to this endpoint. In the test suite, for example, posting `{"type": "device_offline", "data": {"id": "abc"}}` to `/webhook` will enqueue an event. The event queue stores events in the order received.

**Consuming Events:** Agents use `get_next_event` to retrieve events. Key points about `get_next_event`:

* It can be called with an optional filter: `get_next_event({"event_type": "some_type"})`. If an `event_type` is provided, the tool will return the **next event of that type**. If no `event_type` is given, it returns the next event in the queue regardless of type.
* **Blocking behavior:** `get_next_event` will suspend (wait) until an event is available. The server implementation waits on the event queue; if the queue is empty, the call will not return until an event arrives (this is essentially a long-poll for events). This means an agent can call `get_next_event` and it will only respond when an event is delivered. If a filter is set, it will ignore other event types â€“ the code will put unmatched events back into the queue and continue waiting. This ensures that events are not lost or skipped; they remain queued until the agent picks them up.
* **Non-Blocking usage:** If agents need to check for an event without waiting indefinitely, they might call `get_next_event` with a timeout or in a loop with a short wait. (The MCP server itself doesnâ€™t provide a separate â€œpeekâ€ or non-blocking poll method; the agent side would handle timing out if needed.) In tests, for example, they wrapped `get_next_event` in a timeout to avoid waiting forever.
* **Return value:** When an event is retrieved, it will be returned as a JSON object (or Python dict) containing the `type` and `data`. For example, using the earlier posted event, `get_next_event({"event_type": "device_offline"})` would eventually return `{"type": "device_offline", "data": {"id": "abc"}}`. If no filter was used, it would return whichever event was next (which in this case is also that event). The event is then removed from the queue (consumed).

**Using Events in Agents:** Agents can use events to trigger actions without a user request. For instance, an agent could be running a loop that constantly listens for new events:

```python
while True:
    event = get_next_event({})
    if event["type"] == "device_offline":
        handle_device_offline(event["data"])
    elif event["type"] == "incident_created":
        notify_incident(event["data"])
    # ...and so on for different types
```

In a conversational AI context, the agent might call `get_next_event` when it needs to wait for something to happen (e.g., â€œIâ€™ve triggered a reboot, now I will wait for a device\_offline -> online event to confirm it came back.â€). In such a case, providing an `event_type` filter is useful so the agent only wakes up when the expected event arrives.

Common event types are likely things like `device_offline`, `device_online`, `device_error`, `incident_created`, `ticket_created`, etc., depending on what webhooks are configured. The `data` field will contain context for that event (device ID, or incident/ticket details, timestamps, etc.). The agent should parse those and decide on a response. For example, on `device_offline`, the agent could attempt to power-cycle the device (maybe using a prompt/workflow like the reboot workflow described later). On `ticket_created`, an agent could auto-respond or categorize the ticket.

**Error Handling for Events:** If `get_next_event` is called when the server is shutting down or the queue is unavailable, it might return an error or be cancelled, but normally this tool either returns an event or waits. Thereâ€™s no â€œno eventâ€ return â€“ it always waits until something is available (unless you implement a client-side timeout).

**Event Queue Persistence:** The event queue is in-memory. If the server restarts, queued events would be lost. Therefore, itâ€™s wise to have agents consume events promptly. In a robust deployment, one might integrate a persistent message broker for events, but as implemented, itâ€™s transient. Agents might want to periodically confirm they are connected and listening for events, so as not to miss any.

In summary, `get_next_event` enables **reactive behavior** in agents. Use it to handle asynchronous triggers, making your agent proactive and responsive to changes in the environment, not just user queries.

## Async Operations

Some device commands might take a noticeable amount of time to execute, or an agent might need to fire off a command and continue with other tasks. The MCP server provides asynchronous execution tools to accommodate this: **`send_command_async`** and **`get_task_status`**.

### send\_command\_async

`send_command_async` works much like the standard `send_command`, but instead of waiting for the command to complete, it returns immediately with a task identifier. The command execution then proceeds in the background on the server.

* **Inputs:** It accepts the same parameters as `send_command` (`device_id`, `name`, `friendly_name`, etc.). You should provide all necessary info to execute the command on the device. (Context defaults will apply here as well â€“ if `device_id` is not given but context has one, it will use it.)
* **Behavior:** When invoked, the server generates a unique `task_id` (a UUID) for this command execution. It immediately returns a result containing this `task_id`, without waiting for the device to actually perform the command. Internally, the server schedules the command to run in the background. The initial status of the task is â€œpendingâ€.
* **Return Value:** The direct response from `send_command_async` is a simple JSON object: `{"task_id": "<some-unique-id>"}`. This ID is what youâ€™ll use to track the commandâ€™s progress.

For example:

```python
task_info = send_command_async({
    "device_id": "device123",
    "name": "reboot",
    "friendly_name": "Reboot Device"
})
# task_info might be {"task_id": "123e4567-e89b-12d3-a456-426614174000"}
task_id = task_info["task_id"]
```

At this point, the reboot command has been dispatched to run asynchronously. The agent can continue with other logic (or even prompt the user that itâ€™s working in the background).

* The server, meanwhile, is executing the command in a background task. It will update the internal status when done. If the command succeeds, the result (data from the Xyte API) is stored in memory associated with the task ID, and status becomes "done". If the command fails (throws an exception), the status becomes "error" and the error message is saved. Throughout execution, it also reports progress (0% to 100%) to the context, which could be used for streaming status updates (though thatâ€™s more for logging/UI and not exposed via the get\_task\_status call).

### get\_task\_status

After initiating an async task, an agent uses `get_task_status` to query its state. You call it with the `task_id` you received:

```python
status = get_task_status({"task_id": task_id})
```

The output will be a dictionary describing the taskâ€™s state:

* `status`: a string indicating the state. It will be `"pending"` if the command is still in progress, `"done"` if it completed successfully, `"error"` if it failed, or `"unknown"` if the task ID is not recognized (e.g., if itâ€™s wrong or too old and was purged).
* `result`: present when `status` is `"done"`. This contains the result data of the command (essentially what `send_command` would have returned if called synchronously). The structure is usually a dict or JSON â€“ for example, if the command was a reboot, the result might include a confirmation or the command record. If `status` is not done, `result` may be `null` or absent.
* `error`: present when `status` is `"error"`. This will be a message string describing the error that occurred. (It might be a propagated error from Xyteâ€™s API or a timeout message, etc.) If no error occurred, this is `null` or not present.

**Polling Mechanism:** Agents typically should poll `get_task_status` periodically if they need to wait for completion. For instance, an agent might check every few seconds, or use an exponential backoff (check after 1s, then 2s, then 4s, etc.) to see if the task finished. You can also immediately call it once right after `send_command_async` to get an initial status (likely â€œpendingâ€).

Example usage:

```python
# Initiate the command asynchronously
task = send_command_async({ ... })
task_id = task["task_id"]

# Later, check the status
status_info = get_task_status({"task_id": task_id})
if status_info["status"] == "done":
    print("Command completed successfully.")
    result = status_info["result"]
elif status_info["status"] == "error":
    error_msg = status_info["error"]
    print(f"Command failed: {error_msg}")
else:
    # status is "pending" (or potentially "unknown" if something went wrong)
    print("Command still running, please check again later.")
```

In a conversation, the agent might say, "Reboot initiated, I'll let you know once it's done." and then use `get_task_status` in the background until it sees `"done"`, then inform the user.

**Important Considerations:**

* **Task Expiration:** The tasks are stored in-memory on the server in a dictionary. They will persist as long as the server is running. There isnâ€™t a built-in expiration or cleanup (besides the dictionary naturally growing). If the server restarts, all ongoing tasks are lost (theyâ€™d all become â€œunknownâ€). In practice, this means your agent should handle an `"unknown"` status by possibly informing that the result is unavailable (and maybe suggesting to retry the operation if needed).
* **Concurrent tasks:** You can fire off multiple async commands in parallel (each will get its own `task_id`). Just be mindful not to overload the device or violate any sequential command constraints the device might have. The MCP server does not serialize these beyond what the Xyte API allows.
* **When to use async:** Use `send_command_async` when the action might take longer than you want to wait within a single agent turn, or when you want to perform other checks while the command runs. A common use case is a long-running firmware update or a reboot cycle â€“ you start it asynchronously, then perhaps monitor device status via events or periodic checks, rather than blocking the agent completely.

In summary, asynchronous tools give the agent more flexibility and prevent it from getting stuck waiting. Just remember to always pair `send_command_async` with `get_task_status` (and possibly event handling) to know when the operation finished.

## Prompts for Troubleshooting & Automation

To help agents perform complex or common tasks, the MCP server defines some **predefined prompts/workflows**. These are essentially guided sequences or suggestions that an agent can follow to achieve a goal. They encapsulate best practices or standard procedures for automation tasks. Agents (especially AI agents) can use these prompts as a blueprint for what steps to take.

Currently, the server includes a couple of example prompts for troubleshooting scenarios:

* **Reboot Device Workflow:** This prompt (accessible via `reboot_device_workflow(device_id)`) provides step-by-step instructions to safely reboot an unresponsive device. It suggests the agent to:

    1. **Check available commands** on the device by querying the resource `device://{device_id}/commands` â€“ this is to see if a reboot command is supported for that device.
    2. If a reboot command exists, **call the `send_command` tool** with `name="reboot"` (and the given device\_id) to execute a reboot.
    3. After sending the reboot, **verify success by checking the deviceâ€™s history** via `device://{device_id}/histories` â€“ confirming that a reboot event or status change is recorded.

  Essentially, this prompt guides an agent through a safe reboot procedure: first confirm capability, then act, then verify the outcome. An AI agent could use these steps to structure its actions when a device is not responding. By following the prompt, the agent ensures it uses the proper tools in the correct order.

* **Check Projectors Health:** This prompt (`check_projectors_health()`) is a high-level strategy for monitoring all projectorsâ€™ status. The guidance provided is:

    * **List all devices** using `devices://` and filter the list to find devices that are projectors (perhaps by type or name).
    * For each projector device, **inspect its history records** via `device://{device_id}/histories` to look for any recent errors or unusual events.
    * Also **check open incidents** using `incidents://` to see if any ongoing incident is related to those projectors.

  In summary, this prompt tells an agent how to systematically go through all projectors and evaluate their health, combining multiple resource queries. An agent following this could then report â€œAll projectors are functioning normallyâ€ or identify ones with issues (and perhaps drill down further on those).

These prompts are registered with the MCP server as first-class prompts. In an AI agent integration, they might be used behind the scenes to influence the agentâ€™s plan. For example, if an AI has access to a prompt library, it could call or retrieve these prompts when a relevant goal is identified (like â€œreboot deviceâ€ or â€œcheck all projectorsâ€). Each prompt is essentially a template of steps (in the form of either a list of messages or a single message string) that the agent can incorporate into its reasoning or explanation.

**How to Use Prompts:** Depending on your agent setup:

* If you have an AI agent that can retrieve prompts from the server, you might call an API or method to get the prompt by name. The prompt might come as a series of messages or instructions (the reboot workflow is stored as a list of User messages, each containing an instruction).
* The agent can then follow each step, executing the recommended tool/resource calls in sequence, and reporting back as needed.
* These prompts can also serve as **documentation for human agents**. A human operator could read the â€œReboot Device Workflowâ€ to manually follow those steps via the tools.

The idea is to encapsulate domain knowledge or troubleshooting flows so that agents donâ€™t have to figure it all out from scratch. As the MCP server evolves, more prompts or workflows can be added (for example, a workflow to diagnose network issues, or to set up a new device step-by-step). Agents should check if a relevant prompt exists for a task theyâ€™re about to perform â€“ it can save time and ensure best practices.

In the current implementation, prompts are limited (just the two above as examples), but they demonstrate how to combine resources and tools effectively. For instance, the reboot workflow prompt explicitly ties together a resource query (`device://.../commands`) with a tool action (`send_command`) and another resource check (`device://.../histories`). An agent using this will behave more reliably than one that improvises a sequence.

**Summary:** Predefined prompts give structured guidance for common tasks:

* *Troubleshooting prompts* (like reboot workflow) help recover or fix device issues.
* *Automation prompts* (like checking health across devices) help in routine monitoring.

Agents can leverage these to improve their performance. In practical terms, if youâ€™re developing an AI agent, consider these prompts as part of the agentâ€™s prompt (you might feed the steps into the AIâ€™s context when such a task is needed). If youâ€™re a human agent, you can follow the steps manually via the MCP tools and resources.

---

By following this guide, agents should be well-equipped to interact with the MCP server: authenticating properly, invoking the right tools with the right inputs, utilizing context to streamline operations, handling errors robustly, reacting to events, managing long-running commands, and using built-in knowledge to perform complex procedures. The combination of **tools** (for actions) and **resources** (for information) provides a powerful interface to the Xyte platform, all mediated through the MCP server in a consistent way. With these capabilities, an agent (or AI assistant) can automate device management tasks, assist IT/operators, and ensure things run smoothly in an AV/IoT environment.

================
File: registry.yaml
================
openapi: 3.0.0
info:
  title: Xyte Organization API
  version: "1.0"
servers:
  - url: https://hub.xyte.io/core/v1/organization
    description: Production server
security:
  - ApiKeyAuth: []
paths:
  /devices:
    get:
      summary: "Get Devices"
      description: "List all devices in the organization."
      tags:
        - Devices
      responses:
        '200':
          description: OK
  /devices/claim:
    post:
      summary: "Claim Device"
      description: "Register (claim) a new device under the organization."
      tags:
        - Devices
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ClaimDeviceRequest'
            example:
              name: "Friendly device name"
              space_id: 13244
              mac: null
              sn: null
              cloud_id: ""
      responses:
        '200':
          description: OK
  /devices/{device_id}:
    delete:
      summary: "Delete Device"
      description: "Delete (remove) a device by its ID."
      tags:
        - Devices
      parameters:
        - $ref: '#/components/parameters/DeviceId'
      responses:
        '200':
          description: OK
    patch:
      summary: "Update Device"
      description: "Update configuration or details of a specific device."
      tags:
        - Devices
      parameters:
        - $ref: '#/components/parameters/DeviceId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateDeviceRequest'
            example:
              configuration:
                a: 1
      responses:
        '200':
          description: OK
  /devices/histories:
    get:
      summary: "Get Histories"
      description: "Retrieve device history records, filtered by query parameters."
      tags:
        - Devices
      parameters:
        - name: status
          in: query
          schema:
            type: string
          description: Filter by status
        - name: from
          in: query
          schema:
            type: string
            format: date-time
          description: Start of time range
        - name: to
          in: query
          schema:
            type: string
            format: date-time
          description: End of time range
        - name: device_id
          in: query
          schema:
            type: string
          description: Filter by device identifier
        - name: space_id
          in: query
          schema:
            type: integer
          description: Filter by space identifier
        - name: name
          in: query
          schema:
            type: string
          description: Filter by name
      responses:
        '200':
          description: OK
  /devices/{device_id}/commands:
    post:
      summary: "Send Command"
      description: "Send a command to the specified device."
      tags:
        - Commands
      parameters:
        - $ref: '#/components/parameters/DeviceId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CommandRequest'
            example:
              name: "reboot"
              friendly_name: "Reboot"
              file_id: "optional"
              extra_params: {}
      responses:
        '200':
          description: OK
  /devices/{device_id}/commands/{command_id}:
    delete:
      summary: "Cancel Command"
      description: "Cancel a previously sent command on the device."
      tags:
        - Commands
      parameters:
        - $ref: '#/components/parameters/DeviceId'
        - $ref: '#/components/parameters/CommandId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CommandRequest'
            example:
              name: "reboot"
              friendly_name: "Reboot"
              file_id: "optional"
              extra_params: {}
      responses:
        '200':
          description: OK
  /{device_id}/commands:
    get:
      summary: "Get Commands"
      description: "List all commands for the specified device."
      tags:
        - Commands
      parameters:
        - $ref: '#/components/parameters/DeviceId'
      responses:
        '200':
          description: OK
  /info:
    get:
      summary: "Get Organization Info"
      description: "Retrieve information about the organization (requires a device context)."
      tags:
        - Organization
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrgInfoRequest'
            example:
              device_id: "xxxxx"
      responses:
        '200':
          description: OK
  /incidents:
    get:
      summary: "Get Incidents"
      description: "Retrieve all incidents for the organization."
      tags:
        - Incidents
      responses:
        '200':
          description: OK
  /tickets:
    get:
      summary: "Get Tickets"
      description: "Retrieve all support tickets for the organization."
      tags:
        - Tickets
      responses:
        '200':
          description: OK
  /tickets/{ticket_id}:
    get:
      summary: "Get Ticket"
      description: "Retrieve a specific support ticket by ID."
      tags:
        - Tickets
      parameters:
        - $ref: '#/components/parameters/TicketId'
      responses:
        '200':
          description: OK
    put:
      summary: "Update Ticket"
      description: "Update the details of a specific ticket."
      tags:
        - Tickets
      parameters:
        - $ref: '#/components/parameters/TicketId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TicketUpdateRequest'
            example:
              title: "New title"
              description: "New description"
      responses:
        '200':
          description: OK
  /tickets/{ticket_id}/resolved:
    post:
      summary: "Mark Ticket as Resolved"
      description: "Mark the specified ticket as resolved."
      tags:
        - Tickets
      parameters:
        - $ref: '#/components/parameters/TicketId'
      responses:
        '200':
          description: OK
  /tickets/{ticket_id}/message:
    post:
      summary: "Send Ticket Message"
      description: "Send a new message to the specified ticket thread."
      tags:
        - Tickets
      parameters:
        - $ref: '#/components/parameters/TicketId'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TicketMessageRequest'
            example:
              message: "Hello!"
      responses:
        '200':
          description: OK
components:
  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: Authorization
      description: Provide your organization API key or token via the Authorization header.
  parameters:
    DeviceId:
      name: device_id
      in: path
      required: true
      schema:
        type: string
      description: Unique device identifier
    CommandId:
      name: command_id
      in: path
      required: true
      schema:
        type: string
      description: Unique command identifier
    TicketId:
      name: ticket_id
      in: path
      required: true
      schema:
        type: string
      description: Unique ticket identifier
  schemas:
    ClaimDeviceRequest:
      type: object
      properties:
        name:
          type: string
          description: Friendly name for the device
        space_id:
          type: integer
          description: Identifier of the space to assign the device
        mac:
          type: string
          nullable: true
          description: Device MAC address (optional)
        sn:
          type: string
          nullable: true
          description: Device serial number (optional)
        cloud_id:
          type: string
          description: Cloud identifier for the device (optional)
      required:
        - name
        - space_id
    UpdateDeviceRequest:
      type: object
      properties:
        configuration:
          type: object
          description: Configuration parameters for the device
      required:
        - configuration
    CommandRequest:
      type: object
      properties:
        name:
          type: string
          description: Command name
        friendly_name:
          type: string
          description: Human-friendly command name
        file_id:
          type: string
          description: File identifier if the command includes a file (optional)
        extra_params:
          type: object
          description: Additional parameters for the command (if required)
      required:
        - name
        - friendly_name
    OrgInfoRequest:
      type: object
      properties:
        device_id:
          type: string
          description: Device identifier for which to retrieve organization info
      required:
        - device_id
    TicketUpdateRequest:
      type: object
      properties:
        title:
          type: string
          description: New title for the ticket
        description:
          type: string
          description: New description for the ticket
      required:
        - title
        - description
    TicketMessageRequest:
      type: object
      properties:
        message:
          type: string
          description: Message content to send in ticket
      required:
        - message

================
File: requirements.txt
================
# Development dependencies
# For production dependencies, see pyproject.toml

================
File: docs/wrappers.md
================
# XYTE API Wrappers

## Tools

| Name | Parameters |
| ---- | ---------- |
| `claim_device` | name, space_id, mac, sn, cloud_id |
| `delete_device` | device_id |
| `update_device` | device_id, configuration |
| `send_command` | name, friendly_name, file_id, extra_params, device_id |
| `cancel_command` | name, friendly_name, file_id, extra_params, device_id, command_id |
| `update_ticket` | ticket_id, title, description |
| `mark_ticket_resolved` | ticket_id |
| `send_ticket_message` | ticket_id, message |
| `search_device_histories` | status, from_date, to_date, device_id, space_id, name |
| `send_command_async` | name, friendly_name, file_id, extra_params, device_id |
| `get_task_status` | task_id |

## Resources

| URI | Name |
| --- | ---- |
| `devices://` | list_devices |
| `incidents://` | list_incidents |
| `tickets://` | list_tickets |
| `device://{device_id}/commands` | list_device_commands |
| `device://{device_id}/histories` | list_device_histories |
| `organization://info/{device_id}` | organization_info |
| `ticket://{ticket_id}` | get_ticket |
| `user://{user_token}/preferences` | get_user_preferences |
| `user://{user_token}/devices` | list_user_devices |

================
File: helm/templates/deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: xyte-mcp
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: xyte-mcp
  template:
    metadata:
      labels:
        app: xyte-mcp
    spec:
      containers:
      - name: xyte-mcp
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        env:
        - name: XYTE_API_KEY
          valueFrom:
            secretKeyRef:
              name: xyte-secrets
              key: api_key
        ports:
        - containerPort: 8080

================
File: helm/templates/service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: xyte-mcp
spec:
  selector:
    app: xyte-mcp
  ports:
  - port: {{ .Values.service.port }}
    targetPort: 8080
  type: {{ .Values.service.type }}

================
File: helm/Chart.yaml
================
apiVersion: v2
name: xyte-mcp
version: 0.1.0
appVersion: "0.1.0"

================
File: helm/values.yaml
================
replicaCount: 1
image:
  repository: xyte-mcp
  tag: latest
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
  port: 80

================
File: k8s/deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: xyte-mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: xyte-mcp
  template:
    metadata:
      labels:
        app: xyte-mcp
    spec:
      containers:
      - name: xyte-mcp
        image: xyte-mcp:latest
        env:
        - name: XYTE_API_KEY
          valueFrom:
            secretKeyRef:
              name: xyte-secrets
              key: api_key
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10

================
File: k8s/service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: xyte-mcp
spec:
  selector:
    app: xyte-mcp
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP

================
File: src/xyte_mcp_alpha/events.py
================
"""Event handling utilities for asynchronous automation."""

from __future__ import annotations

import asyncio
from typing import Any, Dict, Optional

from pydantic import BaseModel, Field


class Event(BaseModel):
    """Simple event model used for incoming webhooks."""

    type: str = Field(..., description="Event type")
    data: Dict[str, Any] = Field(default_factory=dict, description="Event payload")


# Global queue storing incoming events
_event_queue: asyncio.Queue[Event] = asyncio.Queue()


async def push_event(event: Event) -> None:
    """Add an event to the queue."""
    await _event_queue.put(event)


class GetNextEventRequest(BaseModel):
    """Arguments for ``get_next_event`` tool."""

    event_type: Optional[str] = Field(
        None, description="Only return events matching this type if provided"
    )


async def get_next_event(params: GetNextEventRequest) -> Dict[str, Any]:
    """Return the next queued event matching the optional type."""
    while True:
        event = await _event_queue.get()
        if params.event_type is None or event.type == params.event_type:
            return event.model_dump()
        # Otherwise, put it back at the end of the queue and continue searching
        await _event_queue.put(event)

================
File: src/xyte_mcp_alpha/prompts.py
================
from typing import List
from mcp.server.fastmcp.prompts import base


def reboot_device_workflow(device_id: str) -> List[base.Message]:
    """Workflow instructions for rebooting an unresponsive device."""
    return [
        base.UserMessage(
            f"Check available commands with resource device://{device_id}/commands"
        ),
        base.UserMessage(
            "If a reboot command exists, call the send_command tool with name='reboot'."
        ),
        base.UserMessage(
            f"Verify success via device://{device_id}/histories after execution."
        ),
    ]


def check_projectors_health() -> str:
    """Guide for checking health of all projectors."""
    return (
        "List devices with devices:// and filter for projectors. "
        "For each, inspect device histories via device://{device_id}/histories "
        "and check open incidents using incidents://."
    )


def proactive_projector_maintenance_check() -> List[base.Message]:
    """Prompt to analyze projector usage and suggest maintenance."""
    return [
        base.UserMessage("List all projector devices."),
        base.UserMessage(
            "For each projector, call get_device_analytics_report with period='last_30_days'."
        ),
        base.UserMessage(
            "If lamp hours exceed 80% of expected lifespan, advise creating a support ticket for lamp replacement."
        ),
    ]


def troubleshoot_offline_device_workflow(device_id: str, room_name: str) -> List[base.Message]:
    """Detailed steps for recovering an offline device."""
    return [
        base.UserMessage(
            f"A user reports device {device_id} in room {room_name} is offline."
        ),
        base.UserMessage(
            f"Access resource device://{device_id}/status. If online, inform user."
        ),
        base.UserMessage(
            f"If offline, access device://{device_id}/histories for recent error events."
        ),
        base.UserMessage(
            f"Attempt send_command with name='reboot' to {device_id}. Wait 2 minutes."
        ),
        base.UserMessage(
            f"Re-check device://{device_id}/status. If still offline, create a ticket detailing steps taken and escalate."
        ),
    ]

================
File: tests/test_errors.py
================
import unittest
import httpx

from xyte_mcp_alpha.utils import handle_api, MCPError

class ErrorMappingTestCase(unittest.IsolatedAsyncioTestCase):
    async def test_http_status_error_mapping_invalid_params(self):
        request = httpx.Request("GET", "http://example.com")
        response = httpx.Response(400, request=request, text="bad")
        exc = httpx.HTTPStatusError("bad", request=request, response=response)

        async def failing():
            raise exc

        with self.assertRaises(MCPError) as cm:
            await handle_api("test", failing())
        self.assertEqual(cm.exception.code, "invalid_params")

    async def test_request_error_mapping_network_error(self):
        request = httpx.Request("GET", "http://example.com")
        exc = httpx.ConnectError("boom", request=request)

        async def failing():
            raise exc

        with self.assertRaises(MCPError) as cm:
            await handle_api("test", failing())
        self.assertEqual(cm.exception.code, "network_error")

    async def test_http_status_device_not_found(self):
        request = httpx.Request("GET", "http://example.com")
        response = httpx.Response(404, request=request, text="not found")
        exc = httpx.HTTPStatusError("missing", request=request, response=response)

        async def failing():
            raise exc

        with self.assertRaises(MCPError) as cm:
            await handle_api("get_device", failing())
        self.assertEqual(cm.exception.code, "device_not_found")

if __name__ == "__main__":
    unittest.main()

================
File: tests/test_health.py
================
import unittest
from starlette.testclient import TestClient

from xyte_mcp_alpha.http import app


class HealthEndpointTestCase(unittest.TestCase):
    def setUp(self):
        self.client = TestClient(app)

    def test_health_endpoint(self):
        resp = self.client.get('/healthz')
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(resp.text, 'ok')

    def test_ready_endpoint(self):
        resp = self.client.get('/readyz')
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(resp.text, 'ok')


if __name__ == '__main__':
    unittest.main()

================
File: tests/test_metrics.py
================
import unittest
from starlette.testclient import TestClient

from xyte_mcp_alpha.http import app


class MetricsEndpointTestCase(unittest.TestCase):
    def setUp(self):
        self.client = TestClient(app)

    def test_metrics_endpoint(self):
        resp = self.client.get('/metrics')
        self.assertEqual(resp.status_code, 200)
        self.assertTrue(resp.text)


if __name__ == '__main__':
    unittest.main()

================
File: CHANGELOG.md
================
# Changelog

## [1.0.0] - 2024-06-11
### Added
- Auto-generated MCP capability JSON in `docs/capabilities.json`.
- Swagger-style documentation for XYTE wrappers in `docs/wrappers.md`.
- Inline GIF demo for running `mcp dev`.

### Changed
- Project version bumped to **1.0.0**.

## [1.1.0] - 2025-05-17
### Added
- `start_meeting_room_preset` and `shutdown_meeting_room` high level tools.
- `log_automation_attempt` for feedback collection.
- Dry run support for `send_command` and `delete_device`.
- Prompts for proactive projector maintenance and offline device troubleshooting.

================
File: Dockerfile
================
FROM python:3.11-slim
WORKDIR /app
COPY . .
RUN pip install .
CMD ["serve"]

================
File: .github/workflows/ci.yml
================
name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          pip install .
          pip install ruff
      - name: Run static analysis
        run: ruff check src tests
      - name: Run tests
        run: python -m unittest discover -v
      - name: Security scan
        run: scripts/security_scan.sh || true

================
File: src/xyte_mcp_alpha/deps.py
================
from contextlib import asynccontextmanager
from typing import AsyncIterator, Optional

from .client import XyteAPIClient
from .config import get_settings


@asynccontextmanager
async def get_client(user_token: Optional[str] = None) -> AsyncIterator[XyteAPIClient]:
    """Yield a new API client instance for a request.

    Args:
        user_token: Optional token to use instead of the default API key.
    """
    settings = get_settings()
    api_key = user_token or settings.xyte_user_token or settings.xyte_api_key
    client = XyteAPIClient(api_key=api_key, base_url=settings.xyte_base_url)
    try:
        yield client
    finally:
        await client.close()

================
File: src/xyte_mcp_alpha/logging_utils.py
================
import json
import logging
import time
import uuid
from contextvars import ContextVar
from typing import Any, Callable, Awaitable
from functools import wraps
from prometheus_client import Histogram
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import SimpleSpanProcessor, ConsoleSpanExporter

# Context variable to store request ID for each incoming request
request_id_var: ContextVar[str | None] = ContextVar("request_id", default=None)


def configure_logging(level: int = logging.INFO) -> None:
    """Configure application-wide structured logging."""
    logging.basicConfig(level=level, format="%(message)s")
    provider = TracerProvider()
    provider.add_span_processor(SimpleSpanProcessor(ConsoleSpanExporter()))
    trace.set_tracer_provider(provider)


def log_json(level: int, **fields: Any) -> None:
    """Log a JSON-formatted message, injecting the request ID if present."""
    request_id = request_id_var.get()
    if request_id is not None:
        fields.setdefault("request_id", request_id)
    logging.getLogger("xyte_mcp_alpha").log(level, json.dumps(fields))


class RequestLoggingMiddleware:
    """ASGI middleware that logs requests and responses."""

    def __init__(self, app: Callable):
        self.app = app

    async def __call__(self, scope: dict, receive: Callable, send: Callable) -> None:
        if scope.get("type") != "http":
            await self.app(scope, receive, send)
            return

        request_id = str(uuid.uuid4())
        token = request_id_var.set(request_id)
        method = scope.get("method")
        path = scope.get("path")
        start = time.monotonic()

        log_json(
            logging.INFO, event="request_start", method=method, path=path, request_id=request_id
        )

        async def send_wrapper(message: dict) -> None:
            if message["type"] == "http.response.start":
                status = message["status"]
                log_json(logging.INFO, event="response_start", status=status, request_id=request_id)
            if message["type"] == "http.response.body" and not message.get("more_body", False):
                duration_ms = (time.monotonic() - start) * 1000
                log_json(
                    logging.INFO,
                    event="request_complete",
                    duration_ms=round(duration_ms),
                    request_id=request_id,
                )
            await send(message)

        try:
            await self.app(scope, receive, send_wrapper)
        finally:
            request_id_var.reset(token)


# Prometheus metrics for tools and resources

TOOL_LATENCY = Histogram("xyte_tool_latency_seconds", "Latency of tool handlers", ["tool"])
RESOURCE_LATENCY = Histogram(
    "xyte_resource_latency_seconds", "Latency of resource handlers", ["resource"]
)


def instrument(kind: str, name: str):
    """Decorator to log and measure execution of tools and resources."""

    def decorator(func: Callable[..., Awaitable[Any]]) -> Callable[..., Awaitable[Any]]:
        @wraps(func)
        async def wrapper(*args: Any, **kwargs: Any) -> Any:
            start = time.monotonic()
            log_json(logging.INFO, event=f"{kind}_start", name=name)
            tracer = trace.get_tracer(__name__)
            with tracer.start_as_current_span(f"{kind}:{name}"):
                try:
                    return await func(*args, **kwargs)
                except Exception:
                    log_json(logging.ERROR, event=f"{kind}_error", name=name)
                    raise
                finally:
                    duration = time.monotonic() - start
                    log_json(
                        logging.INFO,
                        event=f"{kind}_complete",
                        name=name,
                        duration_ms=round(duration * 1000),
                    )
                    if kind == "tool":
                        TOOL_LATENCY.labels(name).observe(duration)
                    else:
                        RESOURCE_LATENCY.labels(name).observe(duration)

        from inspect import signature

        wrapper.__signature__ = getattr(func, "__signature__", signature(func))
        return wrapper

    return decorator

================
File: tests/test_validation.py
================
import unittest

from xyte_mcp_alpha import resources
from xyte_mcp_alpha.utils import MCPError

class ValidationTestCase(unittest.IsolatedAsyncioTestCase):
    async def test_invalid_device_id(self):
        with self.assertRaises(MCPError) as cm:
            await resources.list_device_commands("")
        self.assertEqual(cm.exception.code, "invalid_params")

if __name__ == "__main__":
    unittest.main()

================
File: scripts/security_scan.sh
================
#!/usr/bin/env bash
# Simple wrapper around pip-audit for dependency vulnerability scanning
set -euo pipefail

if ! command -v pip-audit >/dev/null 2>&1; then
    echo "pip-audit not found. Install with 'pip install pip-audit'" >&2
    exit 1
fi

pip-audit "$@"

================
File: src/xyte_mcp_alpha/models.py
================
"""Pydantic models used by server tools and resources."""

from typing import Optional, Dict, Any
from pydantic import BaseModel, Field
from .client import CommandRequest


class DeviceId(BaseModel):
    """Model identifying a device."""

    device_id: str = Field(..., description="Unique device identifier")


class TicketId(BaseModel):
    """Model identifying a ticket."""

    ticket_id: str = Field(..., description="Unique ticket identifier")


class CommandId(DeviceId):
    """Model identifying a command for a device."""

    command_id: str = Field(..., description="Unique command identifier")


class UpdateDeviceArgs(DeviceId):
    """Parameters for updating a device."""

    configuration: Dict[str, Any] = Field(..., description="Configuration parameters")


class MarkTicketResolvedRequest(TicketId):
    """Request model for marking a ticket resolved."""


class SendTicketMessageRequest(MarkTicketResolvedRequest):
    message: str = Field(..., description="Message content to send")


class DeleteDeviceArgs(DeviceId):
    """Arguments for deleting a device."""

    dry_run: bool = Field(False, description="Simulate deletion without action")


class SendCommandArgs(CommandRequest):
    """Parameters for sending a command with optional context defaults."""

    device_id: Optional[str] = Field(
        None, description="Identifier of the target device"
    )
    dry_run: bool = Field(False, description="Simulate without sending")


class SendCommandRequest(DeviceId, CommandRequest):
    """Parameters for sending a command."""

    pass


class CancelCommandRequest(CommandId, CommandRequest):
    """Parameters for canceling a command."""

    pass


class UpdateTicketRequest(MarkTicketResolvedRequest):
    title: str = Field(..., description="New title for the ticket")
    description: str = Field(..., description="New description")


class SearchDeviceHistoriesRequest(BaseModel):
    status: Optional[str] = Field(None, description="Filter by status")
    from_date: Optional[str] = Field(None, description="Start ISO time")
    to_date: Optional[str] = Field(None, description="End ISO time")
    device_id: Optional[str] = Field(None, description="Filter by device")
    space_id: Optional[int] = Field(None, description="Filter by space")
    name: Optional[str] = Field(None, description="Filter by name")


class ToolResponse(BaseModel):
    """Standard response model for tools with optional guidance."""

    data: Any
    summary: Optional[str] = None
    next_steps: Optional[list[str]] = None
    related_tools: Optional[list[str]] = None


class FindAndControlDeviceRequest(BaseModel):
    """Parameters for the find_and_control_device tool."""

    room_name: str = Field(..., description="Name of the room to search")
    device_type_hint: Optional[str] = Field(
        None, description="Optional device type hint (projector, display, etc.)"
    )
    action: str = Field(..., description="Action to perform, e.g. power_on")
    input_source_hint: Optional[str] = Field(
        None, description="Optional input source hint"
    )


class DiagnoseAVIssueRequest(BaseModel):
    """Parameters for the diagnose_av_issue tool."""

    room_name: str = Field(..., description="Room to diagnose")
    issue_description: str = Field(..., description="Description of the problem")

================
File: tests/test_rate_limit.py
================
import os
import pytest

from xyte_mcp_alpha.utils import handle_api, MCPError, _REQUEST_TIMESTAMPS
from xyte_mcp_alpha.config import get_settings

class DummyClient:
    async def do(self):
        return {}


dummy = DummyClient()


@pytest.mark.asyncio
async def test_rate_limit_exceeded():
    os.environ["XYTE_RATE_LIMIT"] = "2"
    _REQUEST_TIMESTAMPS.clear()
    get_settings.cache_clear()

    await handle_api("dummy", dummy.do())
    await handle_api("dummy", dummy.do())
    coro = dummy.do()
    with pytest.raises(MCPError) as exc:
        await handle_api("dummy", coro)
    coro.close()
    assert exc.value.code == "rate_limited"

================
File: src/xyte_mcp_alpha/http.py
================
"""HTTP entrypoint for the MCP server."""

from .server import get_server
from .logging_utils import RequestLoggingMiddleware
from .config import get_settings
from fastapi.openapi.utils import get_openapi
from fastapi.openapi.docs import get_swagger_ui_html
from fastapi.responses import JSONResponse, HTMLResponse

# Expose ASGI app for Uvicorn or other ASGI servers
app = get_server().streamable_http_app()
app.add_middleware(RequestLoggingMiddleware)


@app.get("/openapi.json")
async def openapi_spec() -> JSONResponse:
    schema = get_openapi(title="Xyte MCP API", version="1.0", routes=app.routes)
    return JSONResponse(schema)


@app.get("/api/docs")
async def api_docs() -> HTMLResponse:
    return get_swagger_ui_html(openapi_url="/openapi.json", title="Xyte MCP API")


def main():
    """Run the HTTP server using Uvicorn."""
    import uvicorn

    settings = get_settings()
    uvicorn.run("xyte_mcp_alpha.http:app", host="0.0.0.0", port=settings.mcp_inspector_port)


if __name__ == "__main__":
    main()

================
File: src/xyte_mcp_alpha/resources.py
================
"""Resource handlers providing read-only data to MCP clients."""

from typing import Any, Dict

from .deps import get_client
from .utils import handle_api, validate_device_id, validate_ticket_id
from .user import get_preferences


async def list_devices() -> Dict[str, Any]:
    """Return all devices in the organization."""
    async with get_client() as client:
        return await handle_api("get_devices", client.get_devices())


async def list_device_commands(device_id: str) -> Dict[str, Any]:
    """List commands for a specific device."""
    device_id = validate_device_id(device_id)
    async with get_client() as client:
        return await handle_api("get_device_commands", client.get_commands(device_id))


async def list_device_histories(device_id: str) -> Dict[str, Any]:
    """Return history records for a device."""
    device_id = validate_device_id(device_id)
    async with get_client() as client:
        return await handle_api(
            "get_device_histories", client.get_device_histories(device_id=device_id)
        )


async def device_status(device_id: str) -> Dict[str, Any]:
    """Return status information for a single device."""
    device_id = validate_device_id(device_id)
    async with get_client() as client:
        return await handle_api("get_device", client.get_device(device_id))


async def organization_info(device_id: str) -> Dict[str, Any]:
    """Fetch organization information for a device."""
    device_id = validate_device_id(device_id)
    async with get_client() as client:
        return await handle_api(
            "get_organization_info", client.get_organization_info(device_id)
        )


async def list_incidents() -> Dict[str, Any]:
    """List current incidents."""
    async with get_client() as client:
        return await handle_api("get_incidents", client.get_incidents())


async def list_tickets() -> Dict[str, Any]:
    """List all support tickets."""
    async with get_client() as client:
        return await handle_api("get_tickets", client.get_tickets())


async def get_ticket(ticket_id: str) -> Dict[str, Any]:
    """Retrieve a single ticket by ID."""
    ticket_id = validate_ticket_id(ticket_id)
    async with get_client() as client:
        return await handle_api("get_ticket", client.get_ticket(ticket_id))


async def get_user_preferences(user_token: str) -> Dict[str, Any]:
    """Return stored preferences for a specific user."""
    prefs = get_preferences(user_token)
    return prefs.model_dump()


async def list_user_devices(user_token: str) -> Dict[str, Any]:
    """List devices filtered by a user's preferred devices."""
    prefs = get_preferences(user_token)
    async with get_client(user_token) as client:
        devices = await handle_api("get_devices", client.get_devices())

    device_list = devices.get("devices", devices)
    if prefs.preferred_devices:
        device_list = [d for d in device_list if d.get("id") in prefs.preferred_devices]
    if isinstance(devices, dict) and "devices" in devices:
        devices = {"devices": device_list}
    else:
        devices = device_list
    return devices

================
File: tests/test_config.py
================
import os
import unittest

from xyte_mcp_alpha.config import Settings, get_settings


class SettingsTestCase(unittest.TestCase):
    def test_load_settings_from_env(self):
        os.environ['XYTE_API_KEY'] = 'abc'
        os.environ['XYTE_BASE_URL'] = 'http://test'
        os.environ['XYTE_CACHE_TTL'] = '30'
        os.environ['XYTE_RATE_LIMIT'] = '10'
        get_settings.cache_clear()
        s = Settings()
        self.assertEqual(s.xyte_api_key, 'abc')
        self.assertEqual(s.xyte_base_url, 'http://test')
        self.assertEqual(s.xyte_cache_ttl, 30)
        self.assertEqual(s.rate_limit_per_minute, 10)


if __name__ == '__main__':
    unittest.main()

================
File: src/xyte_mcp_alpha/__init__.py
================
"""xyte-mcp-alpha package."""

from dotenv import load_dotenv

from .server import get_server
from .config import get_settings, reload_settings
import signal


def _setup_reload() -> None:
    """Install SIGHUP handler to reload configuration."""

    def handler(_sig, _frame) -> None:
        reload_settings()

    signal.signal(signal.SIGHUP, handler)


_setup_reload()

load_dotenv()

__version__ = "1.1.0"
__all__ = ["get_server", "get_settings", "__version__"]


def serve():
    """Entry point for serving the MCP server."""
    import asyncio
    from mcp.server.stdio import stdio_server

    server = get_server()
    asyncio.run(stdio_server(server))

================
File: pyproject.toml
================
[project]
name = "xyte-mcp-alpha"
version = "1.1.0"
description = "MCP server for Xyte organization API"
authors = [{name = "Your Name", email = "your.email@example.com"}]
license = {text = "MIT"}
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "mcp[cli]>=1.1.0",
    "httpx>=0.27.0",
    "python-dotenv>=1.0.0",
    "pydantic>=2.0.0",
    "cachetools>=5.3.0",
    "prometheus-client>=0.19.0",
    "opentelemetry-sdk>=1.22.0",
]

[project.scripts]
serve = "xyte_mcp_alpha:serve"

[project.urls]
Homepage = "https://github.com/portons/xyte-mcp-alpha"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/xyte_mcp_alpha"]

[tool.ruff]
line-length = 100

================
File: src/xyte_mcp_alpha/config.py
================
from functools import lru_cache
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application configuration loaded from environment variables."""

    model_config = SettingsConfigDict(env_file=".env", case_sensitive=False)

    xyte_api_key: str = Field(..., alias="XYTE_API_KEY")
    xyte_base_url: str = Field(default="https://hub.xyte.io/core/v1/organization", alias="XYTE_BASE_URL")
    xyte_user_token: str | None = Field(default=None, alias="XYTE_USER_TOKEN")
    xyte_cache_ttl: int = Field(default=60, alias="XYTE_CACHE_TTL")
    environment: str = Field("prod", alias="XYTE_ENV")
    rate_limit_per_minute: int = Field(default=60, alias="XYTE_RATE_LIMIT")
    mcp_inspector_port: int = Field(default=8080, alias="MCP_INSPECTOR_PORT")


@lru_cache()
def get_settings() -> Settings:
    """Return a cached Settings instance."""
    return Settings()


def reload_settings() -> None:
    """Clear cached settings so they will be reloaded on next access."""
    get_settings.cache_clear()

================
File: src/xyte_mcp_alpha/tools.py
================
from typing import Any, Dict, Optional
import logging
from pathlib import Path
import json
import anyio

from .deps import get_client
from .utils import handle_api, get_session_state, validate_device_id, MCPError
from . import resources
from mcp.server.fastmcp.server import Context
from .client import (
    ClaimDeviceRequest,
    UpdateDeviceRequest,
    CommandRequest,
    TicketUpdateRequest,
    TicketMessageRequest,
)
from .models import (
    UpdateDeviceArgs,
    MarkTicketResolvedRequest,
    SendTicketMessageRequest,
    SendCommandArgs,
    CancelCommandRequest,
    UpdateTicketRequest,
    SearchDeviceHistoriesRequest,
    ToolResponse,
    DeleteDeviceArgs,
    FindAndControlDeviceRequest,
    DiagnoseAVIssueRequest,
)

logger = logging.getLogger(__name__)


async def claim_device(request: ClaimDeviceRequest) -> Dict[str, Any]:
    """Claim a new device and assign it to the organization.

    Example:
        `claim_device({"name": "Display", "space_id": 1})`
    """
    async with get_client() as client:
        return await handle_api("claim_device", client.claim_device(request))


async def delete_device(data: DeleteDeviceArgs) -> ToolResponse:
    """Delete an existing device by its identifier."""
    if data.dry_run:
        logger.info("Dry run: would delete device", extra={"device_id": data.device_id})
        return ToolResponse(
            data={"dry_run": True}, summary=f"Dry run: Would delete device {data.device_id}"
        )
    async with get_client() as client:
        result = await handle_api("delete_device", client.delete_device(data.device_id))
        return ToolResponse(
            data=result.get("data", result), summary=f"Device {data.device_id} deleted"
        )


async def update_device(data: UpdateDeviceArgs) -> Dict[str, Any]:
    """Apply configuration updates to a device."""
    async with get_client() as client:
        req = UpdateDeviceRequest(configuration=data.configuration)
        return await handle_api("update_device", client.update_device(data.device_id, req))


async def send_command(
    data: SendCommandArgs,
    ctx: Context | None = None,
) -> ToolResponse:
    """Send a command to a device."""
    device_id = data.device_id
    if ctx and not device_id:
        state = get_session_state(ctx)
        device_id = state.get("current_device_id")
        if device_id:
            logger.info("Defaulting device_id from context", extra={"device_id": device_id})
    if not device_id:
        raise MCPError(code="missing_device_id", message="device_id is required")

    async with get_client() as client:
        req = CommandRequest(
            name=data.name,
            friendly_name=data.friendly_name,
            file_id=data.file_id,
            extra_params=data.extra_params or {},
        )
        if ctx:
            state = get_session_state(ctx)
            state["last_command"] = data.name
            await ctx.info(f"Sending command {data.name} to device {device_id}")
            await ctx.report_progress(0.0, 1.0, "sending")

        if data.dry_run:
            logger.info(
                "Dry run: would send command", extra={"device_id": device_id, "command": data.name}
            )
            result = {"dry_run": True}
        else:
            result = await handle_api("send_command", client.send_command(device_id, req))

        if ctx:
            await ctx.report_progress(1.0, 1.0, "done")
        return ToolResponse(
            data=result.get("data", result),
            summary=(
                f"Dry run: would send '{data.friendly_name}'"
                if data.dry_run
                else f"Command '{data.friendly_name}' sent"
            )
            + f" to device {device_id}",
            next_steps=["get_device_status"],
        )


async def cancel_command(data: CancelCommandRequest) -> Dict[str, Any]:
    """Cancel a previously sent command."""
    async with get_client() as client:
        req = CommandRequest(
            name=data.name,
            friendly_name=data.friendly_name,
            file_id=data.file_id,
            extra_params=data.extra_params or {},
        )
        return await handle_api(
            "cancel_command",
            client.cancel_command(data.device_id, data.command_id, req),
        )


async def update_ticket(data: UpdateTicketRequest) -> Dict[str, Any]:
    """Modify the title or description of a support ticket."""
    async with get_client() as client:
        req = TicketUpdateRequest(title=data.title, description=data.description)
        return await handle_api("update_ticket", client.update_ticket(data.ticket_id, req))


async def mark_ticket_resolved(data: MarkTicketResolvedRequest) -> Dict[str, Any]:
    """Mark a ticket as resolved."""
    async with get_client() as client:
        return await handle_api("mark_ticket_resolved", client.mark_ticket_resolved(data.ticket_id))


async def send_ticket_message(data: SendTicketMessageRequest) -> Dict[str, Any]:
    """Post a new message to a ticket conversation."""
    async with get_client() as client:
        req = TicketMessageRequest(message=data.message)
        return await handle_api(
            "send_ticket_message", client.send_ticket_message(data.ticket_id, req)
        )


async def search_device_histories(
    params: SearchDeviceHistoriesRequest,
    ctx: Context | None = None,
) -> Dict[str, Any]:
    """Search device history records with optional filters."""
    async with get_client() as client:
        from datetime import datetime

        from_dt = datetime.fromisoformat(params.from_date) if params.from_date else None
        to_dt = datetime.fromisoformat(params.to_date) if params.to_date else None

        if ctx:
            await ctx.info("Fetching device histories")
            await ctx.report_progress(0.0, 1.0)

        result = await handle_api(
            "search_device_histories",
            client.get_device_histories(
                status=params.status,
                from_date=from_dt,
                to_date=to_dt,
                device_id=params.device_id,
                order=params.order or "DESC",
                page=params.page,
                limit=params.limit,
            ),
        )

        if ctx:
            await ctx.report_progress(1.0, 1.0)

        return result


async def get_device_analytics_report(
    device_id: str,
    period: str = "last_30_days",
    ctx: Context | None = None,
) -> ToolResponse:
    """Retrieve usage analytics for a device."""
    device_id = validate_device_id(device_id)
    async with get_client() as client:
        if ctx:
            await ctx.info("Fetching analytics")
        result = await handle_api(
            "get_device_analytics",
            client.get_device_analytics(device_id, period=period),
        )
        return ToolResponse(data=result.get("data", result))


async def set_context(
    device_id: Optional[str] = None,
    space_id: Optional[str] = None,
    ctx: Context | None = None,
) -> ToolResponse:
    """Set session context defaults for subsequent tool calls."""
    if ctx is None:
        raise MCPError(code="missing_context", message="Context required")

    state = get_session_state(ctx)
    if device_id is not None:
        state["current_device_id"] = device_id
    if space_id is not None:
        state["current_space_id"] = space_id

    return ToolResponse(data=state, summary="Context updated")


async def start_meeting_room_preset(
    room_name: str,
    preset_name: str,
    ctx: Context | None = None,
) -> ToolResponse:
    """Configure a meeting room for a preset workflow."""
    if ctx:
        await ctx.info(f"Configuring {room_name} for {preset_name}")
        await ctx.report_progress(0.0, 1.0, "starting")
    # Placeholder logic. Real implementation would orchestrate multiple commands
    await anyio.sleep(0)  # yield control
    if ctx:
        await ctx.report_progress(1.0, 1.0, "done")
    return ToolResponse(
        data={"room_name": room_name, "preset_name": preset_name},
        summary=f"Room {room_name} set to {preset_name} preset",
    )


async def shutdown_meeting_room(
    room_name: str,
    ctx: Context | None = None,
) -> ToolResponse:
    """Power down AV equipment in the specified room."""
    if ctx:
        await ctx.info(f"Shutting down room {room_name}")
        await ctx.report_progress(0.0, 1.0, "shutting_down")
    await anyio.sleep(0)
    if ctx:
        await ctx.report_progress(1.0, 1.0, "done")
    return ToolResponse(
        data={"room_name": room_name},
        summary=f"Shutdown routine completed for {room_name}",
    )


async def log_automation_attempt(
    workflow_name: str,
    device_id: str,
    steps_taken: list[str],
    outcome: str,
    user_feedback: Optional[str] = None,
    error_details: Optional[str] = None,
    ctx: Context | None = None,
) -> ToolResponse:
    """Record the result of an automated workflow."""
    entry = {
        "workflow_name": workflow_name,
        "device_id": device_id,
        "steps_taken": steps_taken,
        "outcome": outcome,
        "user_feedback": user_feedback,
        "error_details": error_details,
    }
    path = Path("logs") / "automation.log"
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(entry) + "\n")
    logger.info("automation_attempt", extra=entry)
    if ctx:
        await ctx.info("Automation attempt logged")
    return ToolResponse(data=entry, summary="Attempt recorded")


async def find_and_control_device(
    data: FindAndControlDeviceRequest,
    ctx: Context | None = None,
) -> ToolResponse:
    """Find a device by room/name hints and perform an action."""
    async with get_client() as client:
        devices = await handle_api("get_devices", client.get_devices())

    device_list = devices.get("devices", devices)
    matches = []
    room = data.room_name.lower()
    for dev in device_list:
        if room in str(dev.get("space_name", "")).lower():
            if (
                data.device_type_hint
                and data.device_type_hint not in str(dev.get("type", "")).lower()
            ):
                continue
            matches.append(dev)

    if not matches:
        from difflib import get_close_matches

        names = [d.get("space_name", "") for d in device_list]
        close = get_close_matches(room, names, n=1)
        if close:
            matches = [d for d in device_list if d.get("space_name") == close[0]]

    if not matches:
        raise MCPError(code="device_not_found", message="No matching device found")

    device = matches[0]
    summary = f"Selected {device.get('name')} in {device.get('space_name')}"
    if ctx:
        await ctx.info(summary)

    cmd = SendCommandArgs(
        device_id=device.get("id"),
        name=data.action,
        friendly_name=data.action.replace("_", " "),
        extra_params={"input": data.input_source_hint} if data.input_source_hint else {},
    )
    result = await send_command(cmd, ctx=ctx)
    return ToolResponse(
        data={"device": device, "command": result.data},
        summary=summary + f" -> {data.action}",
    )


async def diagnose_av_issue(
    data: DiagnoseAVIssueRequest,
    ctx: Context | None = None,
) -> ToolResponse:
    """Run basic diagnostics for a room based on an issue description."""
    async with get_client() as client:
        devices = await handle_api("get_devices", client.get_devices())

    room_lower = data.room_name.lower()
    device = next(
        (
            d
            for d in devices.get("devices", devices)
            if room_lower in str(d.get("space_name", "")).lower()
        ),
        None,
    )

    if not device:
        raise MCPError(code="device_not_found", message="No device found for room")

    status = await resources.device_status(device["id"])
    histories = await search_device_histories(
        SearchDeviceHistoriesRequest(device_id=device["id"]),
        ctx=ctx,
    )

    return ToolResponse(
        data={"status": status, "histories": histories},
        summary="Diagnostics gathered",
        next_steps=["send_command"],
    )

================
File: .env.example
================
# Xyte MCP Server Configuration
XYTE_API_KEY=your-api-key-here
# Optional: Override the API base URL (defaults to production)
# XYTE_BASE_URL=https://hub.xyte.io/core/v1/organization
# Optional: per-user token overriding XYTE_API_KEY
# XYTE_USER_TOKEN=override-token
# Optional: cache TTL in seconds
# XYTE_CACHE_TTL=60
# Optional: set environment name
# XYTE_ENV=dev
# Optional: max MCP requests per minute
# XYTE_RATE_LIMIT=60

================
File: docs/spec.md
================
XYTE MCP Server - Enhanced Implementation Plan (v2)
Overall Goals (Revised):
Elevate the MCP server to be exceptionally user-friendly for end-users interacting via AI agents.
Maximize robustness, security, and maintainability.
Pioneer advanced AI-driven AV automation capabilities.
Solidify industry-leading best practices in its architecture and features.
Provide an outstanding developer experience for AI agent creators.
A. Codebase Analysis, Refinement, and Best Practice Alignment (Continued)
This section focuses on completing the foundational improvements.
[x] Task A1: Deep Code Review and SDK Alignment
Description: Conduct a thorough review of src/xyte_mcp_alpha/server.py, client.py (previously clients/xyte.py), and models.py (previously schemas.py). Ensure consistent and optimal use of FastMCP.
Rationale: Identify any manual MCP protocol handling that could be simplified by SDK features, ensure type hinting is consistently used for better validation and editor support, and optimize the interaction flow between MCP requests, Xyte API client, and response handling.
Action Items:
Verify that tool, resource, and prompt definitions leverage SDK decorators and features correctly (e.g., Context object, ToolAnnotations).
Refactor any overly complex logic in request handling or client interactions.
Ensure the XyteAPIClient (client.py) efficiently manages connections, utilizes caching effectively (review TTLCache usage), and gracefully handles API-specific errors before they are translated to MCPError.
Confirm Pydantic models in models.py are optimally structured for both API interaction and MCP schema generation.
[x] Task A3: Strengthen Error Handling and Reporting
Description: Expand on the existing error handling (MCPError exceptions, Xyte API status code translation in utils.py). Implement more granular and user-friendly error reporting.
Rationale: Provides clearer feedback to AI agents and aids debugging. The current translation of Xyte API errors is good; this task aims to make it comprehensive and more informative for the AI.
Action Items:
Map a wider range of Xyte API errors (beyond common HTTP codes) to specific, descriptive MCPError codes (e.g., DeviceCommandFailedError, TicketNotFoundError).
Ensure consistent error structure in responses, potentially including suggestions for resolution if applicable (e.g., "Device offline, try rebooting?").
For critical errors, provide enough context in server logs (without exposing sensitive data) for easier diagnosis.
Utilize the Context object (from FastMCP) more extensively for standardized error logging and reporting within tools/resources.
Review utils.handle_api for completeness in error catching and reporting.
[x] Task C5: Deep Integration with Xyte Universal Device APIs & Advanced Features
Description: Ensure the MCP server tools and resources fully leverage the advanced capabilities advertised by Xyte for their Universal Device APIs and any other new platform features.
Rationale: Xyte's own announcements emphasize synergy with MCP for AI-driven automation (automated room recovery, dynamic reassignment, proactive maintenance). This task is about going deeper than the current toolset.
Action Items:
Thoroughly review the latest Xyte platform documentation for any new or advanced API endpoints related to device control, diagnostics, analytics, or configuration that are not yet exposed.
Develop specific MCP tools that map directly to these advanced AV management tasks (e.g., initiateDeviceDiagnostics, getDeviceAnalyticsReport, applyConfigurationTemplateToSpace).
Explore exposing more granular device telemetry or configuration parameters as distinct resources if beneficial for AI agents.
B. Enhancing MCP Core Functionality (Tools, Resources, Prompts)
Tasks B1-B4 were marked as complete. This section will now focus on new tools/resources based on further needs.
C. Implementing Additional Functionalities
Tasks C1-C4 were marked as complete. This section will now focus on new functionalities.
D. Operational Excellence and Developer Experience (Continued)
[x] Task D1: Expand Test Coverage
Description: Enhance the existing pytest suite (e.g., test_errors.py, test_validation.py) with more comprehensive unit, integration, and contract tests.
Rationale: Ensures reliability and catches regressions. Testing MCP servers involves mocking client interactions and validating responses against defined schemas.
Action Items:
Unit Tests: For individual functions in tools.py, resources.py, client.py, utils.py, models.py, tasks.py, events.py.
Integration Tests: For MCP tool/resource handlers, mocking the XyteAPIClient to test the logic within the MCP server. Specifically test error translation, context handling, and progress reporting.
Contract Tests: Ensure that all tools/resources strictly adhere to their defined MCP schemas (as per docs/capabilities.json). This can be automated by validating actual tool/resource outputs against their schemas.
Workflow Tests: Create tests for common multi-tool sequences defined by prompts.
Review existing tests (test_config.py, test_discovery_and_events.py, test_health.py, test_metrics.py, test_rate_limit.py) for any gaps.
[x] Task D2: Implement/Verify Full CI/CD Pipeline
Description: Ensure the CI/CD pipeline (GitHub Actions: .github/workflows/ci.yml) is comprehensive.
Rationale: Automates testing, building, and deployment, improving development velocity and reliability.
Action Items:
Verify ci.yml runs all tests (unit, integration, contract).
Ensure linting (ruff) and code formatting checks are enforced.
Automate building the Docker image (Dockerfile) and pushing it to a container registry.
Automate deployment to staging/production environments using Helm charts (helm/) or K8s manifests (k8s/).
Add security scanning (like the existing scripts/security_scan.sh using pip-audit) as a mandatory step in the CI pipeline.
[x] Task D4: Performance Profiling and Optimization
Description: Proactively profile the MCP server, especially Xyte API interactions via client.py and cache effectiveness.
Rationale: Ensures the MCP server is responsive. The existing Prometheus metrics (TOOL_LATENCY, RESOURCE_LATENCY, REQUEST_LATENCY in logging_utils.py) are a great start.
Action Items:
Use profiling tools to identify any non-obvious bottlenecks in Python code, especially in data transformation or complex logic.
Analyze cache hit/miss ratios for TTLCache in XyteAPIClient and optimize TTLs or cache strategies if needed.
Optimize Xyte API query patterns if specific calls are consistently slow (e.g., fetching too much data when only a subset is needed).
Review asynchronous operations in tasks.py for efficiency and resource usage.
[x] Task D5: Dependency Management and Upgrades
Description: Regularly review and update dependencies listed in pyproject.toml.
Rationale: Benefits from new features, performance improvements, and crucial security patches.
Action Items:
Establish a schedule for reviewing dependency updates (e.g., quarterly).
Utilize tools like pip-audit or GitHub's Dependabot to automate vulnerability detection in dependencies.
Test thoroughly after any significant dependency upgrade, especially mcp, fastmcp, httpx, and pydantic.
E. Enhanced User Experience & Agent Usability (NEW SECTION)
This section focuses on making the AI agent, powered by this MCP server, exceptionally helpful and intuitive for the end-user.
[x] Task E1: Develop "Smart" Tools with Natural Language Understanding (NLU) Hints
Description: Create a new set of tools or enhance existing ones to better understand more natural, slightly ambiguous user requests by providing clear NLU hints in their descriptions or expecting structured "intent" objects.
Rationale: Simplifies interaction for AI agents, allowing them to translate user needs more directly into actions without complex intermediate logic. This makes the agent more usable.
Action Items:
Tool: findAndControlDevice:
Input: { "room_name": "string", "device_type_hint": "projector|display|audio", "action": "power_on|power_off|set_input", "input_source_hint": "hdmi1|sharelink" }
Description: "Attempts to find a device in a specified room, optionally matching a type, and perform an action. Uses fuzzy matching for room/device names if exact match fails. Clearly state assumptions if any are made."
Logic: Internally, this tool would list devices, filter by room/type, and then call send_command.
Tool: diagnoseAVIssue:
Input: { "room_name": "string", "issue_description": "No audio from laptop" }
Description: "Performs a series of diagnostic steps for a common AV issue in a room. Returns findings and suggested next actions."
Logic: This tool could chain several resource calls (device status, histories) and basic checks.
Update tool descriptions to guide AI on how to formulate calls based on common user phrasing.
[x] Task E2: Implement Context-Aware Defaulting in Tools
Description: Modify tools to intelligently use existing session context (e.g., a previously targeted device_id or space_id) if not explicitly provided in a subsequent call.
Rationale: Reduces verbosity for AI agents in multi-turn interactions, making conversations feel more natural.
Action Items:
Enhance utils.get_session_state(ctx) to store/retrieve current_device_id, current_space_id.
Modify tools like send_command to check session state for device_id if not provided in args, with clear logging when a default is used.
Provide a tool setContext ({ "device_id": "string", "space_id": "string" }) for the AI to explicitly set the context.
[x] Task E3: Design Richer Feedback Mechanisms
Description: Enhance tool responses to include not just data but also human-readable summaries, status interpretations, and potential next steps or related tools.
Rationale: Helps the AI provide more comprehensive and helpful responses to the end-user.
Action Items:
Modify tool return schemas to include optional fields like summary: string, next_steps: List[str], related_tools: List[str].
Example: get_device_status could return: {"data": {...}, "summary": "Projector is ON and input is HDMI1.", "next_steps": ["send_command to change input", "get_device_histories for recent activity"]}.
[x] Task E4: Create High-Level Abstraction Tools for Common User Goals
Description: Develop tools that encapsulate common multi-step AV workflows, abstracting the complexity from the AI agent.
Rationale: Makes it easier for AI agents to achieve common end-user goals with a single tool call.
Action Items:
Tool: startMeetingRoomPreset:
Input: { "room_name": "string", "preset_name": "presentation|videoconference" }
Description: "Configures the specified meeting room for a given preset (e.g., turns on display, sets input, adjusts audio)."
Logic: Internally calls multiple send_command or update_device tools based on predefined room configurations.
Tool: shutdownMeetingRoom:
Input: { "room_name": "string" }
Description: "Powers down all relevant AV equipment in the specified meeting room."
F. Advanced AI Integration & Automation (NEW SECTION)
This section focuses on enabling more sophisticated, proactive, and intelligent automation through the AI agent.
[x] Task F1: Develop Proactive Maintenance Tools & Prompts
Description: Create tools and prompts that allow an AI agent to identify potential issues from device data and suggest or initiate proactive maintenance.
Rationale: Shifts from reactive to proactive AV management, a key value proposition for AI.
Action Items:
Tool: getDeviceUsageAnalytics:
Input: { "device_id": "string", "period": "last_30_days" }
Output: { "lamp_hours_used": "number", "power_on_cycles": "number", ... }
Description: "Retrieves usage analytics for a device that might indicate upcoming maintenance needs."
Prompt: Proactive Projector Maintenance Check:
Content: "1. List all projector devices. 2. For each, get its usage analytics (lamp hours). 3. If lamp hours exceed 80% of expected lifespan, suggest creating a ticket for lamp replacement."
Ensure search_device_histories can filter for error patterns or specific event types indicative of failing hardware.
[x] Task F2: Implement "Self-Healing" Workflow Prompts
Description: Design detailed MCP prompts that guide an AI agent through automated troubleshooting and resolution sequences for common AV problems.
Rationale: Enables the AI agent to autonomously resolve issues, reducing downtime and support load.
Action Items:
Prompt: Troubleshoot Offline Device Workflow:
Content: "A user reports device {device_id} in room {room_name} is offline.
Access resource device://{device_id}/status. If online, inform user.
If offline, access device://{device_id}/histories for recent error events.
Attempt send_command with name='reboot' to {device_id}. Wait 2 minutes.
Re-check device://{device_id}/status.
If still offline, create a ticket detailing steps taken and escalate."
The existing reboot_device_workflow prompt is a good start; expand on this concept for other issues (no audio, no video).
[x] Task F3: Structured Logging for AI Learning (Feedback Loop)
Description: Implement a tool that allows the AI agent (or its developers) to log the outcome of automation attempts or user feedback in a structured format.
Rationale: This data can be invaluable for fine-tuning the AI agent, improving its decision-making, or identifying frequently failing automation paths. This is about enabling a feedback loop.
Action Items:
Tool: logAutomationAttempt:
Input: { "workflow_name": "string", "device_id": "string", "steps_taken": "list[string]", "outcome": "success|failure|user_corrected", "user_feedback": "string (optional)", "error_details": "string (optional)" }
Description: "Logs the details and outcome of an automated task or user interaction. This data is used for improving future AI performance."
Logic: Writes to a dedicated log file or a database/analytics service (outside MCP server's direct scope, but tool provides the interface).
G. Cutting-Edge Practices & Future-Proofing (NEW SECTION)
This section explores advanced architectural and design considerations.
[x] Task G1: Enhanced Observability with Distributed Tracing
Description: Integrate OpenTelemetry (or similar) for distributed tracing across MCP tool executions, Xyte API calls, and any asynchronous tasks.
Rationale: Provides deep insights into request flows, performance bottlenecks, and error propagation in complex interactions, especially as the system grows. The current request_id_var in logging_utils.py is a good foundation.
Action Items:
Instrument key functions in server.py, tools.py, resources.py, client.py, and tasks.py with OpenTelemetry tracing.
Ensure trace IDs are propagated through asynchronous operations and logged consistently.
Configure an exporter to a tracing backend (e.g., Jaeger, Zipkin, or a cloud provider's service).
[x] Task G2: Dynamic Configuration Reloading
Description: Implement a mechanism for the MCP server to reload certain configurations (e.g., XYTE_CACHE_TTL, XYTE_RATE_LIMIT from config.py) without a full restart.
Rationale: Improves operational flexibility, allowing for dynamic adjustments in a running system.
Action Items:
Explore using a signal handler (e.g., SIGHUP) or a dedicated admin tool/endpoint to trigger a configuration reload.
Ensure get_settings() and dependent components can gracefully handle updated configuration values.
[x] Task G3: Implement "Dry Run" Mode for Destructive Tools
Description: Add a dry_run: bool parameter to all destructive tools (e.g., delete_device, send_command). If true, the tool should simulate the action and report what would happen without actually performing it.
Rationale: Critical for safety, allowing AI agents (and users) to verify the impact of an action before committing. This is a strong best practice for automation APIs.
Action Items:
Update Pydantic models for relevant tools to include an optional dry_run field.
Modify tool logic: if dry_run is true, perform all checks and validations, then return a success-like message indicating what would have been done (e.g., "Dry run: Would have deleted device X").
The Xyte API itself may not support dry runs, so this would be a simulation at the MCP server level.
H. Developer Experience (for AI Agent Devs) (NEW SECTION)
This section focuses on making it easier and more efficient for developers to build AI agents that consume this MCP server.
[x] Task H1: Interactive API Documentation & Sandbox (Beyond mcp dev)
Description: If the HTTP interface (http.py) is intended for direct developer use (not just stdio_server), generate and host interactive API documentation (e.g., Swagger UI/Redoc from an OpenAPI spec).
Rationale: mcp dev is great for MCP-specific interactions, but a standard HTTP API doc is useful if devs integrate via raw HTTP. docs/capabilities.json and docs/wrappers.md are good static docs.
Action Items:
Ensure docs/capabilities.json (or an equivalent OpenAPI spec generated from FastMCP) is complete and accurate.
Set up a simple way to serve Swagger UI or Redoc, pointing to this spec, perhaps as another endpoint on the HTTP server (e.g., /api/docs).
[x] Task H2: Example AI Agent Snippets/SDK
Description: Provide example code snippets or a lightweight client-side helper library (e.g., in Python) demonstrating how to easily call the MCP server's tools and interpret responses.
Rationale: Lowers the barrier to entry for AI agent developers and promotes best practices in using the MCP server.
Action Items:
Create a examples/ directory in the project.
Add Python scripts showing:
Connecting to the stdio_server.
Calling a few key tools (e.g., list_devices, send_command, search_device_histories).
Handling responses and errors.
Using a prompt.
(Optional) Develop a small Python client library that wraps mcp-client calls with functions specific to this server's tools, providing type hinting for requests/responses.
[x] Task H3: Clear Versioning and Changelog Discipline
Description: Maintain a strict API versioning strategy for the MCP server and diligently update CHANGELOG.md for all user-facing changes.
Rationale: Essential for consumers of the API to manage updates and understand the impact of new versions. The current CHANGELOG.md and pyproject.toml versioning are good.
Action Items:
Formalize an API versioning approach (e.g., path-based /v1/tool/... or header-based) if significant breaking changes are anticipated in the future. For now, semantic versioning of the server itself is key.
Ensure every PR that changes tool schemas, resource formats, or server behavior includes an update to CHANGELOG.md.
This revised plan should provide a comprehensive roadmap for taking your XYTE MCP server to the next level of usability, capability, and robustness.

================
File: src/xyte_mcp_alpha/client.py
================
"""Xyte Organization API client."""

import logging
from typing import Any, Dict, Optional
import httpx
from cachetools import TTLCache
from pydantic import BaseModel, Field
from datetime import datetime
import anyio
from prometheus_client import Counter
from .config import get_settings

logger = logging.getLogger(__name__)

# Prometheus counters for cache monitoring - register at module level
CACHE_HITS = Counter(
    "xyte_cache_hits_total",
    "Number of cache hits",
    ["key"],
)
CACHE_MISSES = Counter(
    "xyte_cache_misses_total",
    "Number of cache misses",
    ["key"],
)


class ClaimDeviceRequest(BaseModel):
    """Request model for claiming a device."""

    name: str = Field(..., description="Friendly name for the device")
    space_id: int = Field(..., description="Identifier of the space to assign the device")
    mac: Optional[str] = Field(None, description="Device MAC address (optional)")
    sn: Optional[str] = Field(None, description="Device serial number (optional)")
    cloud_id: str = Field("", description="Cloud identifier for the device (optional)")


class UpdateDeviceRequest(BaseModel):
    """Request model for updating a device."""

    configuration: Dict[str, Any] = Field(
        ..., description="Configuration parameters for the device"
    )


class CommandRequest(BaseModel):
    """Request model for sending a command to device."""

    name: str = Field(..., description="Command name")
    friendly_name: str = Field(..., description="Human-friendly command name")
    file_id: Optional[str] = Field(
        None, description="File identifier if the command includes a file"
    )
    extra_params: Dict[str, Any] = Field(default_factory=dict, description="Additional parameters")


class OrgInfoRequest(BaseModel):
    """Request model for getting organization info."""

    device_id: str = Field(
        ..., description="Device identifier for which to retrieve organization info"
    )


class TicketUpdateRequest(BaseModel):
    """Request model for updating a ticket."""

    title: str = Field(..., description="New title for the ticket")
    description: str = Field(..., description="New description for the ticket")


class TicketMessageRequest(BaseModel):
    """Request model for sending a ticket message."""

    message: str = Field(..., description="Message content to send in ticket")


class XyteAPIClient:
    """Client for interacting with Xyte Organization API."""

    def __init__(self, api_key: Optional[str] = None, base_url: Optional[str] = None):
        """Initialize the API client.

        Args:
            api_key: API key for authentication. If not provided, will try to get from env.
            base_url: Base URL for the API. Defaults to production URL.
        """
        settings = get_settings()
        self.api_key = api_key or settings.xyte_api_key
        if not self.api_key:
            raise ValueError("XYTE_API_KEY must be provided or set in environment")

        self.base_url = base_url or settings.xyte_base_url
        limits = httpx.Limits(max_keepalive_connections=20, max_connections=100)
        transport = httpx.AsyncHTTPTransport(retries=3, limits=limits)
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            headers={
                "Authorization": self.api_key,
                "Content-Type": "application/json",
            },
            timeout=30.0,
            transport=transport,
        )
        self.cache = TTLCache(maxsize=128, ttl=settings.xyte_cache_ttl)

    def cache_stats(self) -> Dict[str, Any]:
        """Return simple cache statistics for monitoring."""
        return {"size": len(self.cache), "ttl": self.cache.ttl}

    def _request_timeout(self) -> float | None:
        """Return remaining time before the current cancel scope deadline."""
        try:
            deadline = anyio.current_effective_deadline()
        except RuntimeError:
            return None
        if deadline == float("inf"):
            return None
        remaining = deadline - anyio.current_time()
        if remaining <= 0:
            raise httpx.TimeoutException("Deadline exceeded")
        return remaining

    async def __aenter__(self) -> "XyteAPIClient":
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self.close()

    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()

    # Device Operations
    async def get_devices(self) -> Dict[str, Any]:
        """List all devices in the organization."""
        if "devices" in self.cache:
            CACHE_HITS.labels(key="devices").inc()
            return self.cache["devices"]
        CACHE_MISSES.labels(key="devices").inc()
        response = await self.client.get("/devices", timeout=self._request_timeout())
        response.raise_for_status()
        data = response.json()
        self.cache["devices"] = data
        return data

    async def claim_device(self, device_data: ClaimDeviceRequest) -> Dict[str, Any]:
        """Register (claim) a new device under the organization."""
        response = await self.client.post(
            "/devices/claim",
            json=device_data.model_dump(exclude_none=True),
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    async def get_device(self, device_id: str) -> Dict[str, Any]:
        """Return details and status for a single device."""
        cache_key = f"device:{device_id}"
        if cache_key in self.cache:
            CACHE_HITS.labels(key="device").inc()
            return self.cache[cache_key]
        CACHE_MISSES.labels(key="device").inc()
        response = await self.client.get(f"/devices/{device_id}", timeout=self._request_timeout())
        response.raise_for_status()
        data = response.json()
        self.cache[cache_key] = data
        return data

    async def delete_device(self, device_id: str) -> Dict[str, Any]:
        """Delete (remove) a device by its ID."""
        response = await self.client.delete(
            f"/devices/{device_id}", timeout=self._request_timeout()
        )
        response.raise_for_status()
        return response.json()

    async def update_device(
        self, device_id: str, device_data: UpdateDeviceRequest
    ) -> Dict[str, Any]:
        """Update configuration or details of a specific device."""
        response = await self.client.patch(
            f"/devices/{device_id}",
            json=device_data.model_dump(),
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    async def get_device_histories(
        self,
        status: Optional[str] = None,
        from_date: Optional[datetime] = None,
        to_date: Optional[datetime] = None,
        device_id: Optional[str] = None,
        space_id: Optional[int] = None,
        name: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Retrieve device history records."""
        params = {}
        if status:
            params["status"] = status
        if from_date:
            params["from"] = from_date.isoformat()
        if to_date:
            params["to"] = to_date.isoformat()
        if device_id:
            params["device_id"] = device_id
        if space_id:
            params["space_id"] = space_id
        if name:
            params["name"] = name

        response = await self.client.get(
            "/devices/histories",
            params=params,
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    async def get_device_analytics(
        self, device_id: str, period: str = "last_30_days"
    ) -> Dict[str, Any]:
        """Retrieve usage analytics for a device."""
        response = await self.client.get(
            f"/devices/{device_id}/analytics",
            params={"period": period},
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    # Command Operations
    async def send_command(self, device_id: str, command_data: CommandRequest) -> Dict[str, Any]:
        """Send a command to the specified device."""
        response = await self.client.post(
            f"/devices/{device_id}/commands",
            json=command_data.model_dump(),
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    async def cancel_command(
        self, device_id: str, command_id: str, command_data: CommandRequest
    ) -> Dict[str, Any]:
        """Cancel a previously sent command on the device."""
        response = await self.client.delete(
            f"/devices/{device_id}/commands/{command_id}",
            json=command_data.model_dump(),
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    async def get_commands(self, device_id: str) -> Dict[str, Any]:
        """List all commands for the specified device."""
        response = await self.client.get(
            f"/devices/{device_id}/commands", timeout=self._request_timeout()
        )
        response.raise_for_status()
        return response.json()

    # Organization Operations
    async def get_organization_info(self, device_id: str) -> Dict[str, Any]:
        """Retrieve information about the organization."""
        # Note: This is a GET request with a body, which is unusual but as specified in the API
        response = await self.client.request(
            "GET",
            "/info",
            json={"device_id": device_id},
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    # Incident Operations
    async def get_incidents(self) -> Dict[str, Any]:
        """Retrieve all incidents for the organization."""
        if "incidents" in self.cache:
            CACHE_HITS.labels(key="incidents").inc()
            return self.cache["incidents"]
        CACHE_MISSES.labels(key="incidents").inc()
        response = await self.client.get("/incidents", timeout=self._request_timeout())
        response.raise_for_status()
        data = response.json()
        self.cache["incidents"] = data
        return data

    # Ticket Operations
    async def get_tickets(self) -> Dict[str, Any]:
        """Retrieve all support tickets for the organization."""
        if "tickets" in self.cache:
            CACHE_HITS.labels(key="tickets").inc()
            return self.cache["tickets"]
        CACHE_MISSES.labels(key="tickets").inc()
        response = await self.client.get("/tickets", timeout=self._request_timeout())
        response.raise_for_status()
        data = response.json()
        self.cache["tickets"] = data
        return data

    async def get_ticket(self, ticket_id: str) -> Dict[str, Any]:
        """Retrieve a specific support ticket by ID."""
        response = await self.client.get(f"/tickets/{ticket_id}", timeout=self._request_timeout())
        response.raise_for_status()
        return response.json()

    async def update_ticket(
        self, ticket_id: str, ticket_data: TicketUpdateRequest
    ) -> Dict[str, Any]:
        """Update the details of a specific ticket."""
        response = await self.client.put(
            f"/tickets/{ticket_id}",
            json=ticket_data.model_dump(),
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

    async def mark_ticket_resolved(self, ticket_id: str) -> Dict[str, Any]:
        """Mark the specified ticket as resolved."""
        response = await self.client.post(
            f"/tickets/{ticket_id}/resolved", timeout=self._request_timeout()
        )
        response.raise_for_status()
        return response.json()

    async def send_ticket_message(
        self, ticket_id: str, message_data: TicketMessageRequest
    ) -> Dict[str, Any]:
        """Send a new message to the specified ticket thread."""
        response = await self.client.post(
            f"/tickets/{ticket_id}/message",
            json=message_data.model_dump(),
            timeout=self._request_timeout(),
        )
        response.raise_for_status()
        return response.json()

================
File: src/xyte_mcp_alpha/utils.py
================
import logging
import time
from typing import Any, Dict, Awaitable, TYPE_CHECKING
from collections import deque

from pydantic import ValidationError
from .config import get_settings

from .models import DeviceId, TicketId

import httpx
from prometheus_client import Counter, Histogram

logger = logging.getLogger(__name__)

if TYPE_CHECKING:  # pragma: no cover - imported for type hints only
    from mcp.server.fastmcp.server import Context


class MCPError(Exception):
    """Simple error class used for MCP responses."""

    def __init__(self, code: str, message: str) -> None:
        super().__init__(message)
        self.code = code

# Prometheus metrics
REQUEST_LATENCY = Histogram(
    "xyte_request_latency_seconds", "Latency of API calls", ["endpoint"]
)
ERROR_COUNT = Counter("xyte_errors_total", "XYTE API errors", ["endpoint", "code"])
STATUS_COUNT = Counter("xyte_status_total", "XYTE API status codes", ["status"])

# Audit logger for security related events
audit_logger = logging.getLogger("audit")

# Simple in-memory rate limiter
_REQUEST_TIMESTAMPS: deque[float] = deque()


def enforce_rate_limit() -> None:
    """Enforce rate limiting for API requests.
    
    Raises:
        MCPError: If rate limit is exceeded
    """
    now = time.time()
    limit = get_settings().rate_limit_per_minute
    
    # Remove timestamps older than 60 seconds
    while _REQUEST_TIMESTAMPS and _REQUEST_TIMESTAMPS[0] < now - 60:
        _REQUEST_TIMESTAMPS.popleft()
    
    if len(_REQUEST_TIMESTAMPS) >= limit:
        raise MCPError(
            code="rate_limited",
            message=f"Rate limit exceeded. Maximum {limit} requests per minute."
        )
    
    _REQUEST_TIMESTAMPS.append(now)


def validate_device_id(device_id: str) -> str:
    """Validate and sanitize a device identifier."""
    try:
        value = DeviceId(device_id=device_id).device_id.strip()
        if not value:
            raise ValueError("device_id cannot be empty")
        return value
    except (ValidationError, ValueError) as exc:  # pragma: no cover - simple validation
        raise MCPError(code="invalid_params", message=str(exc))


def validate_ticket_id(ticket_id: str) -> str:
    """Validate and sanitize a ticket identifier."""
    try:
        return TicketId(ticket_id=ticket_id).ticket_id.strip()
    except ValidationError as exc:  # pragma: no cover - simple validation
        raise MCPError(code="invalid_params", message=str(exc))


async def handle_api(endpoint: str, coro: Awaitable[Any]) -> Dict[str, Any]:
    """Handle API response with error conversion and metrics reporting."""
    enforce_rate_limit()
    
    start_time = time.time()
    try:
        result = await coro
        
        # Track latency
        REQUEST_LATENCY.labels(endpoint=endpoint).observe(time.time() - start_time)
        
        # Convert response to dict if needed
        if hasattr(result, "model_dump"):
            return {"data": result.model_dump()}
        elif not isinstance(result, dict):
            return {"data": result}
        return result
        
    except httpx.HTTPStatusError as e:
        status = str(e.response.status_code)
        STATUS_COUNT.labels(status=status).inc()
        ERROR_COUNT.labels(endpoint=endpoint, code=status).inc()
        
        # Log security-related errors
        if e.response.status_code in [401, 403]:
            audit_logger.warning(
                f"Security error accessing {endpoint}",
                extra={"status": status, "endpoint": endpoint}
            )
        
        error_text = e.response.text
        try:
            error_data = e.response.json()
            error_message = error_data.get("error", error_text)
        except Exception:
            error_message = error_text or f"HTTP {status} error"

        code = f"http_{status}"
        if e.response.status_code == 404:
            if "device" in endpoint:
                code = "device_not_found"
            elif "ticket" in endpoint:
                code = "ticket_not_found"
        elif e.response.status_code == 503:
            code = "service_unavailable"

        raise MCPError(code=code, message=error_message)
        
    except ValidationError as e:
        ERROR_COUNT.labels(endpoint=endpoint, code="validation_error").inc()
        err_msg = str(e).replace('\n', '; ')
        raise MCPError(
            code="validation_error",
            message=f"Invalid data format: {err_msg}"
        )
        
    except httpx.TimeoutException:
        ERROR_COUNT.labels(endpoint=endpoint, code="timeout").inc()
        raise MCPError(
            code="timeout",
            message="Request timed out"
        )
        
    except httpx.NetworkError as e:
        ERROR_COUNT.labels(endpoint=endpoint, code="network_error").inc()
        raise MCPError(
            code="network_error",
            message=f"Network error: {str(e)}"
        )
        
    except Exception as e:
        ERROR_COUNT.labels(endpoint=endpoint, code="unknown_error").inc()
        logger.exception(f"Unknown error in {endpoint}")
        raise MCPError(
            code="unknown_error",
            message=f"Unexpected error: {type(e).__name__}"
        )


def get_session_state(ctx: "Context") -> Dict[str, Any]:
    """Get session state dictionary for a context."""
    if not hasattr(ctx, "_xyte_state"):
        ctx._xyte_state = {}  # type: ignore
    return ctx._xyte_state  # type: ignore


def convert_device_id(device_id: str | int | None) -> str:
    """Convert device ID to string format."""
    if device_id is None:
        raise MCPError(
            code="invalid_device_id",
            message="Device ID is required"
        )
    return str(DeviceId(device_id=device_id).device_id)


def convert_ticket_id(ticket_id: str | int | None) -> str:
    """Convert ticket ID to string format."""
    if ticket_id is None:
        raise MCPError(
            code="invalid_ticket_id", 
            message="Ticket ID is required"
        )
    return str(TicketId(ticket_id=ticket_id).ticket_id)

================
File: README.md
================
# Xyte MCP Server

An MCP (Model Context Protocol) server that provides access to the Xyte Organization API, enabling AI assistants to interact with Xyte devices, commands, tickets, and more.

## Features

This MCP server exposes the following capabilities:

All resources and tools return structured JSON objects rather than plain strings.

### Resources (Read-only)
- `devices://` - List all devices in the organization
- `device://{device_id}/commands` - List commands for a specific device
- `device://{device_id}/histories` - Get history records for a device
- `device://{device_id}/status` - Get current status for a device
- `organization://info/{device_id}` - Get organization info for a device context
- `incidents://` - Retrieve all incidents
- `tickets://` - List all support tickets
- `ticket://{ticket_id}` - Get a specific ticket
- `user://{user_token}/preferences` - Get user preferences
- `user://{user_token}/devices` - List devices filtered by user

### Tools (Actions)
- `claim_device` - Register a new device
- `delete_device` - Remove a device
- `update_device` - Update device configuration
- `send_command` - Send a command to a device
- `cancel_command` - Cancel a pending command
- `update_ticket` - Update ticket details
- `mark_ticket_resolved` - Mark a ticket as resolved
- `send_ticket_message` - Send a message to a ticket
- `search_device_histories` - Search device histories with filters
- `send_command_async` - Send a command asynchronously
- `get_task_status` - Query async task status

## Installation

1. Clone the repository:
```bash
git clone https://github.com/portons/xyte-mcp-alpha.git
cd xyte-mcp-alpha
```

2. Create a virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install the package in editable mode:
```bash
pip install -e .
```

## Configuration

1. Copy the example environment file:
```bash
cp .env.example .env
```

2. Edit `.env` and add your Xyte API key:
```
XYTE_API_KEY=your-actual-api-key-here
```

## Usage

### Running the Server

There are several ways to run the MCP server:

1. Using the installed command:
```bash
serve
```

2. Using Python module:
```bash
python -m xyte_mcp_alpha
```

3. Using MCP CLI for development:
```bash
mcp dev src/xyte_mcp_alpha/server.py
```

4. Running over HTTP with Uvicorn:
```bash
python -m xyte_mcp_alpha.http
```

### Connecting to Claude Desktop

To use this server with Claude Desktop, add it to your configuration file:

**macOS/Linux:** `~/.claude/config.json`
**Windows:** `%APPDATA%\claude\config.json`

```json
{
  "mcpServers": {
    "xyte": {
      "command": "serve",
      "env": {
        "XYTE_API_KEY": "your-api-key-here"
      }
    }
  }
}
```

Alternatively, with a Python virtual environment:

```json
{
  "mcpServers": {
    "xyte": {
      "command": "/path/to/xyte-mcp-alpha/venv/bin/python",
      "args": ["-m", "xyte_mcp_alpha"],
      "env": {
        "XYTE_API_KEY": "your-api-key-here"
      }
    }
  }
}
```

## Example Usage

![mcp dev demo](docs/mcp-dev.gif)

## Development

### Running Tests

```bash
pytest
```

### Using the MCP Inspector

For development and debugging:

```bash
mcp dev src/xyte_mcp_alpha/server.py
```

If port 6277 is already in use, you can specify a different port:

```bash
MCP_INSPECTOR_PORT=6278 mcp dev src/xyte_mcp_alpha/server.py
```

This opens an interactive UI where you can test tools and resources.

## Logging and Monitoring

Structured JSON logs are produced for every HTTP request and Xyte API call. Each
log entry includes a unique `request_id` for easy tracing. Prometheus metrics are
available at the `/metrics` endpoint, including latency histograms for tools,
resources and underlying API calls.

## API Reference

### Environment Variables

- `XYTE_API_KEY` (required) - Your Xyte organization API key
- `XYTE_BASE_URL` (optional) - Override the API base URL (defaults to production)
- `XYTE_USER_TOKEN` (optional) - Per-user token to override the global API key
- `XYTE_CACHE_TTL` (optional) - TTL in seconds for cached API responses (default 60)
- `XYTE_ENV` (optional) - Deployment environment name (`dev`, `staging`, `prod`)
- `XYTE_RATE_LIMIT` (optional) - Maximum MCP requests per minute (default 60)
- `MCP_INSPECTOR_PORT` (optional) - Port for the MCP inspector to use (default 6277)

### Security Considerations

Ensure the value provided for `XYTE_API_KEY` has only the permissions required
for the tools you expose. Avoid logging this key or any per-user token. Run
`scripts/security_scan.sh` regularly to check dependencies for vulnerabilities.

### Error Handling

Errors are surfaced to clients using `MCPError` exceptions. Xyte API status codes are translated to
meaningful MCP error codes such as `unauthorized`, `invalid_params`, `not_found`, `method_not_allowed`,
`rate_limited`, or `xyte_server_error`. Network issues are returned as `network_error`.
All errors are logged for debugging purposes.

### Context Defaults

Use the new `set_context` tool to store a default `device_id` or `space_id` for the session. Tools like
`send_command` will automatically fall back to these values if parameters are omitted.

### Device Analytics

The `get_device_analytics_report` tool exposes advanced analytics from the Xyte API to AI agents.

### Room Preset Tools

Use `start_meeting_room_preset` and `shutdown_meeting_room` to quickly prepare or power down a room. These tools abstract multiple device commands into a single call.

### Dry Run Mode

Destructive tools like `send_command` and `delete_device` now accept a `dry_run` flag. When true, the server will log the intended action but skip calling the Xyte API.

## License

MIT

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

================
File: src/xyte_mcp_alpha/server.py
================
"""MCP server for Xyte Organization API."""

import logging
import sys
import os
from typing import Any, Dict

# Import the GetNextEventRequest class directly
from xyte_mcp_alpha.events import GetNextEventRequest

# Handle different import scenarios
if __name__ == "__main__" or __name__ == "xyte_mcp_alpha.server":
    # When run as a script or imported as part of the package
    try:
        # When imported as part of the package
        from .logging_utils import configure_logging, instrument
        from . import resources, tools, tasks, events, prompts
    except ImportError:
        # When run directly as a script
        sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
        from xyte_mcp_alpha.logging_utils import configure_logging, instrument
        import xyte_mcp_alpha.resources as resources
        import xyte_mcp_alpha.tools as tools
        import xyte_mcp_alpha.tasks as tasks
        import xyte_mcp_alpha.events as events
        import xyte_mcp_alpha.prompts as prompts
else:
    # When imported by MCP dev or other external tools
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
    from xyte_mcp_alpha.logging_utils import configure_logging, instrument
    import xyte_mcp_alpha.resources as resources
    import xyte_mcp_alpha.tools as tools
    import xyte_mcp_alpha.tasks as tasks
    import xyte_mcp_alpha.events as events
    import xyte_mcp_alpha.prompts as prompts

from prometheus_client import CONTENT_TYPE_LATEST, generate_latest
from starlette.requests import Request
from starlette.responses import Response, JSONResponse

from mcp.server.fastmcp import FastMCP
from mcp.types import ToolAnnotations

# Configure structured logging
configure_logging()
logger = logging.getLogger(__name__)
audit_logger = logging.getLogger("audit")
audit_logger.setLevel(logging.INFO)

# Initialize MCP server
mcp = FastMCP("Xyte Organization MCP Server")


@mcp.custom_route("/healthz", methods=["GET"])
async def health(_: Request) -> Response:
    """Liveness probe."""
    return Response("ok")


@mcp.custom_route("/readyz", methods=["GET"])
async def ready(_: Request) -> Response:
    """Readiness probe."""
    return Response("ok")


@mcp.custom_route("/metrics", methods=["GET"])
async def metrics(_: Request) -> Response:
    """Expose Prometheus metrics."""
    data = generate_latest()
    return Response(data, media_type=CONTENT_TYPE_LATEST)


@mcp.custom_route("/tools", methods=["GET"])
async def list_tools(_: Request) -> JSONResponse:
    """List available tools."""
    tools_list = []
    for tool_name, tool_def in mcp.server.tools.items():
        tools_list.append({
            "name": tool_name,
            "description": tool_def.description,
            "readOnlyHint": tool_def.annotations.readOnlyHint if tool_def.annotations else True,
            "destructiveHint": tool_def.annotations.destructiveHint if tool_def.annotations else False,
        })
    return JSONResponse({"tools": tools_list})


# Resource registrations
mcp.resource("devices://", description="List all devices")(
    instrument("resource", "list_devices")(resources.list_devices)
)
mcp.resource(
    "device://{device_id}/commands",
    description="Commands issued to a device",
)(instrument("resource", "list_device_commands")(resources.list_device_commands))
mcp.resource(
    "device://{device_id}/histories",
    description="History records for a device",
)(instrument("resource", "list_device_histories")(resources.list_device_histories))
mcp.resource(
    "device://{device_id}/status",
    description="Current status of a device",
)(instrument("resource", "device_status")(resources.device_status))
mcp.resource(
    "organization://info/{device_id}",
    description="Organization info for a device",
)(instrument("resource", "organization_info")(resources.organization_info))
mcp.resource("incidents://", description="Current incidents")(
    instrument("resource", "list_incidents")(resources.list_incidents)
)
mcp.resource("tickets://", description="All support tickets")(
    instrument("resource", "list_tickets")(resources.list_tickets)
)
mcp.resource("ticket://{ticket_id}", description="Single support ticket")(
    instrument("resource", "get_ticket")(resources.get_ticket)
)
mcp.resource(
    "user://{user_token}/preferences",
    description="Preferences for a user",
)(resources.get_user_preferences)
mcp.resource(
    "user://{user_token}/devices",
    description="Devices filtered by user",
)(resources.list_user_devices)

# Tool registrations
mcp.tool(
    description="Register a new device",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "claim_device")(tools.claim_device))
mcp.tool(
    description="Remove a device from the organization",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "delete_device")(tools.delete_device))
mcp.tool(
    description="Update configuration for a device",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "update_device")(tools.update_device))
mcp.tool(
    description="Send a command to a device",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "send_command")(tools.send_command))
mcp.tool(
    description="Cancel a previously sent command",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=False),
)(instrument("tool", "cancel_command")(tools.cancel_command))
mcp.tool(
    description="Update ticket details",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "update_ticket")(tools.update_ticket))
mcp.tool(
    description="Resolve a ticket",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "mark_ticket_resolved")(tools.mark_ticket_resolved))
mcp.tool(
    description="Send a message to a ticket",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=False),
)(instrument("tool", "send_ticket_message")(tools.send_ticket_message))
mcp.tool(
    description="Search device history records",
    annotations=ToolAnnotations(readOnlyHint=True),
)(instrument("tool", "search_device_histories")(tools.search_device_histories))
mcp.tool(
    description="Retrieve usage analytics for a device",
    annotations=ToolAnnotations(readOnlyHint=True),
)(instrument("tool", "get_device_analytics_report")(tools.get_device_analytics_report))
mcp.tool(
    description="Set context defaults",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=False),
)(instrument("tool", "set_context")(tools.set_context))
mcp.tool(
    description="Find and control a device with natural language hints",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "find_and_control_device")(tools.find_and_control_device))
mcp.tool(
    description="Diagnose an AV issue in a room",
    annotations=ToolAnnotations(readOnlyHint=True),
)(instrument("tool", "diagnose_av_issue")(tools.diagnose_av_issue))
mcp.tool(
    description="Start meeting room preset",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "start_meeting_room_preset")(tools.start_meeting_room_preset))
mcp.tool(
    description="Shutdown meeting room",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(instrument("tool", "shutdown_meeting_room")(tools.shutdown_meeting_room))
mcp.tool(
    description="Log automation attempt",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=False),
)(instrument("tool", "log_automation_attempt")(tools.log_automation_attempt))
mcp.tool(
    description="Send a command asynchronously",
    annotations=ToolAnnotations(readOnlyHint=False, destructiveHint=True),
)(tasks.send_command_async)
mcp.tool(
    description="Get status of an asynchronous task",
    annotations=ToolAnnotations(readOnlyHint=True),
)(tasks.get_task_status)
# Create a wrapper function with explicit type annotation
async def get_next_event_wrapper(params: GetNextEventRequest) -> Dict[str, Any]:
    """Wrapper for get_next_event with explicit type annotation."""
    return await events.get_next_event(params)

# Register the wrapper function as a tool
mcp.tool(
    description="Retrieve the next queued event",
    annotations=ToolAnnotations(readOnlyHint=True),
)(instrument("tool", "get_next_event")(get_next_event_wrapper))

# Prompt registrations
mcp.prompt()(prompts.reboot_device_workflow)
mcp.prompt()(prompts.check_projectors_health)
mcp.prompt()(prompts.proactive_projector_maintenance_check)
mcp.prompt()(prompts.troubleshoot_offline_device_workflow)


def get_server() -> Any:
    """Get the MCP server instance."""
    return mcp


# Allow direct execution for development
if __name__ == "__main__":
    print("Starting MCP server in development mode...")
    import asyncio
    from mcp.server.stdio import stdio_server

    asyncio.run(stdio_server(mcp))



================================================================
End of Codebase
================================================================
